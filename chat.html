<html><head><meta https-equiv="Content-Type" content="text/html; charset=windows-1252">
    <!---<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.dev.js"></script> --->
    <script src="./bw.rnih.org_files/socket.io.js.download"></script>
    <!---<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.0.3/socket.io.js"></script>--->
    <!---socket.io@2.3.0 --->
    <!---<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script> --->
    
    <!--- check ye shit https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity https://www.youtube.com/user/YaleCourses/videos --->
    
    <!---<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>--->
    <script src="./bw.rnih.org_files/jquery.min.js.download"></script>
    
    <!---<link rel="stylesheet" href="w3.css">--->
    <!---<script src="https://code.jquery.com/jquery-3.4.1.js" integrity="sha384-mlceH9HlqLp7GMKHrj5Ara1+LvdTZVMx4S1U43/NxCvAkzIo8WJ0FE7duLel3wVo" crossorigin="anonymous"></script>--->
    <script src="./bw.rnih.org_files/firebase-app.js.download"></script>
    <script src="./bw.rnih.org_files/firebase-auth.js.download"></script>
    <script src="./bw.rnih.org_files/firebase-firestore.js.download"></script>
    <!---<script src="https://www.google.com/recaptcha/api.js?render=6LcEX8QUAAAAADjiUPfbzkyn0KYAaEK263quzCGh"></script>-->
    
    <!---<link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>--->
    
    
    
    <!--<link href="https://bw.rnih.org/js/easy-autocomplete.min.css" rel="stylesheet" type="text/css">
    https://api.bitwave.tv/api/channel/markpugner/
    <script src="https://bw.rnih.org/js/jquery.easy-autocomplete.min.js" type="text/javascript"></script>-->
    
    <!--<link href = "https://code.jquery.com/ui/1.10.4/themes/ui-lightness/jquery-ui.css"
         rel = "stylesheet">-->
    <!--- Adds support for autocomplete of user names https://api.jqueryui.com/autocomplete/--->
    <!--<script src="https://code.jquery.com/jquery-1.12.4.js"></script>-->
    <!--<script src="https://imankulov.github.io/js/jquery-1.3.2.min.js"></script>-->
    
    <!--<script src="https://code.jquery.com/jquery-migrate-1.4.1.js"></script>
    <script src="https://code.jquery.com/jquery-migrate-3.3.0.min.js"></script>-->
    <!--<script src="https://imankulov.github.io/js/jquery.a-tools-1.4.1.js"></script>
    <script src="https://imankulov.github.io/js/jquery.asuggest.js"></script>-->
    
    <!--<script src = "https://code.jquery.com/ui/1.10.4/jquery-ui.js"></script>-->
    
    <!--<link href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css" rel="stylesheet" type="text/css">
    
    <script src = "https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"></script>-->
    
    
    
    <link rel="stylesheet" href="./bw.rnih.org_files/icon">
    <!--- 
  
    
    <link rel="stylesheet" type="text/css" href="deps/css/bootstrap.css">
    <link rel="stylesheet" type="text/css" href="deps/css/responsive.css">
    
    <link rel="stylesheet" type="text/css" href="library/css/bootstrap-linkpreview.css">
    https://www.digitalocean.com/community/questions/blocked-by-cors-policy-the-access-control-allow-origin-mean-stack
    <script type="text/javascript" src="deps/js/jquery-1.8.3.min.js"></script>
    <script type="text/javascript" src="library/js/bootstrap-linkpreview.js"></script>
    
    
    
    --->
    <style>
        body{background-color:#2f2f2f}
        
        html{
            font-size: 14px;
            }
        
        ol {
            display: block;
            list-style-type: decimal;
            margin-top: 0em;
            margin-bottom: 1em;
            margin-left: 0;
            margin-right: 0;
            padding-left: 0;
            width: 475px;
            height: 600px;
            overflow-x:hidden;
         overflow-y: scroll;
           
        }
        
        .disconnected{
            background-color:#FF0000;
        }
        
        div.containment{
            height:600px;
        
        }
        
        .rainbow-text {
        background-image: repeating-linear-gradient(45deg, violet, indigo, blue, green, yellow, orange, red, violet);
        text-align: center;
        background-size: 800% 800%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-size: 24px;
        animation: rainbow 8s ease infinite;
        }

        @keyframes rainbow { 
            0%{background-position:0% 50%}
            50%{background-position:100% 25%}
            100%{background-position:0% 50%}
        }

        
        div.messagesc{
         background-color:#0f0f0f;
         background-color:#000000;
         height: 600px;
         width:475px;
         color:#cfcfcf;
         max-height: 600px;
         
        }
        
        li {
            
            width: 475px;
            color: white;
        }
        
        .date {
            padding-left: 5px;
            float: left;
            margin-right: 5px;
        }
        
        .username {
            margin-left: 5px;
            float: left;
            overflow-x:hidden;
            overflow-y:hidden;
            overflow:hidden;
            max-height: 22px;
            max-width: 200px;
        }
        
        
        .channel {
            padding-right: 5px;
            overflow-x:hidden;
            overflow-y:hidden;
            overflow:hidden;
            max-height: 22px;
            float: right;
            display: block;
            background-color:rgba(96,125,139,0.6);
            max-width: 120px;
        }
        
        a {
            color:#2196f3;
        }
        
        message {
        
        
            margin-right: 30px;
            //margin-right: 0;
            width: 380px;
            float: left;
            display: block;
            font-size: 14px;
            font-family:Roboto,sans-serif;
            overflow-wrap: break-word;
            min-height: 30px;
        }
        
        .avatar{
            float: left;
            width: 34px;
            height: 34px;
            
        }
        
        .userav{
            width: 34px;
            height: 34px;
            border-radius: 50%;
        }
        
        .material-icons {
            font-family: 'Material Icons';
            font-weight: normal;
            font-style: normal;
            font-size: 24px;
            line-height: 1;
            letter-spacing: normal;
            text-transform: none;
            display: inline-block;
            white-space: nowrap;
            word-wrap: normal;
            direction: ltr;
            -webkit-font-feature-settings: 'liga';
            -webkit-font-smoothing: antialiased;
        }
        
        h1, h2, h3, h4, h5, h6 {
            line-height: 1.0;
        }
        
        h1 {
            display: block;
            font-size: 2em;
            margin-block-start: 0.67em;
            margin-block-end: 0.67em;
            margin-inline-start: 0px;
            margin-inline-end: 0px;
            font-weight: bold;
        }
        
        h1 {
        font-size: 1.375rem;
        font-weight: 700;
        }
        h2 {
        font-size: 1.25rem;
        font-weight: 700;
        }
        h3 {
        font-size: 1.00rem;
        font-weight: 700;
        }
        h4 {
        font-size: 0.875rem;
        font-weight: 500;
        }
        h5 {
        font-size: 0.75rem;
        font-weight: 500;
        }
        h6 {
        font-size: 0.625rem;
        font-weight: 500;
        }
        
        message blockquote p{
            display: block;
            background-repeat: no-repeat;
            padding: 0;
            margin: 0;
            margin-left: 0;
            margin-right:0;
            //margin-right: 30px;
            //width: 380px;
            overflow-wrap: break-word;
        }
        
        message  p span{
            //display: block;
            background-repeat: no-repeat;
            padding: 0;
            margin: 0;
            margin-left: 0;
            margin-right:0;
            //margin-right: 30px;
            //width: 380px;
            overflow-wrap: break-word;
            height: 28;
        }
        
        message blockquote {
            display: block;
            background-repeat: no-repeat;
            padding: 0;
            margin: 0;
            margin-left: 0;
            margin-right:0;
            //width: 380px;
            overflow-wrap: break-word;
        }
        
         hr {
            //display: block;
            margin-left: 0;
            margin-right:0;
            width: 380px;
            height: 1px;
            padding: 0;
            margin: 0;
        }
        
        blockquote {
            //width: 380px;
            margin-left: 0;
            display: block;
            background-repeat: no-repeat;
            padding: 0;
            margin: 0;
            margin-left: 0;
            margin-right:0;
            
            margin-inline-start: 0;
            margin-inline-end: 0;
            min-height: 30px;
            overflow-wrap: break-word;
        }

        p img {
            height: 28px;
            vertical-align: middle;
        }
        
        h1 img { 
            max-width:380px; height: auto;
        }
        
        .date {
            user-select: none;
            color: #757575;
        }
        
        .highlight{
            font-weight: bold;
            color: yellow;
        
        }
        
        blockquote p {
            font-weight: 500;
            color: #789922;
            
            margin-left: 0;
            display: block;
            background-repeat: no-repeat;
            padding: 0;
            margin: 0;
            margin-left: 0;
            overflow-wrap: break-word;
        }
        
        .localfag {
            background-color: #f5f5f5;
            color: #bd4147;
        }
        
        code{
            display: inline-block;
            border-radius: 3px;
            white-space: pre-wrap;
            font-size: 85%;
            font-weight: 900;

            background-color: #f5f5f5;
            color: #bd4147;
            box-shadow: 0 2px 1px -1px rgba(0,0,0,.2), 0 1px 1px 0 rgba(0,0,0,.14), 0 1px 3px 0 rgba(0,0,0,.12);
            font-family: monospace,monospace;
            overflow-wrap: break-word;
        }
        
        .labelhelper{
            display: inline-block;
            color: #789922;
        }
        
        .chatWrapper{
            display: block;
        }
        
        .chatHelpers{
            clear: left;
        }
        
        .maincont{
            //overflow: auto;
        }
        
        .hide{
            display: none;
        }
        
        .whisperWindow{
        
        }
        
        .dmWindow{
           
        }
        
        .ttsOptions{
            
        }
        
        .pollArea{
        
        
        }
        
        .fixedCookieNotice{
            position: fixed;
            bottom: 0;
            right: 0;
            width: 300px;
            border: 3px solid #73AD21;
            color: #789922;
            text-align:center;
        }
        
        .alertArea{
            position: fixed;
            top: 30;
            left: 20;
            width: 400;
            height: 300;
            
        
        }
        
        .dmsArea{
            position: fixed;
            top: 30;
            left: 20;
            width: 400;
            height: 300;
            
        
        }
        
        .whispersArea{
            position: fixed;
            top: 30;
            left: 20;
            width: 400;
            height: 300;
            
        
        }
        
        .userlist{
            position: fixed;
            top: 30;
            left: 20;
            width: 400;
            height: 600;
            background-color:#0f0f0f;
        }
        
        .column {
            float: left;
            width: 40.33%;
            padding: 5px;
        }
        
        .column2 {
            float: right;
            width: 40.33%;
            padding: 15px;
        }
        
        .row:after {
            content: "";
            display: table;
            clear: both;
        }
        
        .glow {
            
            color: #fff;
            text-align: center;
            -webkit-animation: glow 1s ease-in-out infinite alternate;
            -moz-animation: glow 1s ease-in-out infinite alternate;
            animation: glow 1s ease-in-out infinite alternate;
        }
        
        .glowgreen {
            
            color: #00ff00;
            text-align: center;
            -webkit-animation: glow 1s ease-in-out infinite alternate;
            -moz-animation: glow 1s ease-in-out infinite alternate;
            animation: glow 1s ease-in-out infinite alternate;
        }

        @-webkit-keyframes glow {
        from {
            text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #e60073, 0 0 40px #e60073, 0 0 50px #e60073, 0 0 60px #e60073, 0 0 70px #e60073;
        }
        to {
            text-shadow: 0 0 20px #fff, 0 0 30px #ff4da6, 0 0 40px #ff4da6, 0 0 50px #ff4da6, 0 0 60px #ff4da6, 0 0 70px #ff4da6, 0 0 80px #ff4da6;
        }
        }
        
        /* Responsive layout - makes the three columns stack on top of each other instead of next to each other */
        @media screen and (max-width:600px) {
            .column {
                width: 100%;
            }
        }
        
        /* The Modal (background) */
.modal {
  display: none; /* Hidden by default */
  position: fixed; /* Stay in place */
  z-index: 1; /* Sit on top */
  left: 0;
  top: 0;
  width: 100%; /* Full width */
  height: 100%; /* Full height */
  overflow: auto; /* Enable scroll if needed */
  background-color: rgb(0,0,0); /* Fallback color */
  background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
  padding-top: 60px;
}

.modalShow {
  display: block; /* Hidden by default */
  position: fixed; /* Stay in place */
  z-index: 1; /* Sit on top */
  left: 0;
  top: 0;
  width: 100%; /* Full width */
  height: 100%; /* Full height */
  overflow: auto; /* Enable scroll if needed */
  background-color: rgb(0,0,0); /* Fallback color */
  background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
  padding-top: 60px;
}

/* Modal Content/Box */
.modal-content {
  background-color: #fefefe;
  margin: 5px auto; /* 15% from the top and centered */
  border: 1px solid #888;
  width: 80%; /* Could be more or less, depending on screen size */
}



/* The Close Button */
.close {
  /* Position it in the top right corner outside of the modal */
  position: absolute;
  right: 25px;
  top: 0; 
  color: #000;
  font-size: 35px;
  font-weight: bold;
}

/* Close button on hover */
.close:hover,
.close:focus {
  color: red;
  cursor: pointer;
}

/* Add Zoom Animation */
.animate {
  -webkit-animation: animatezoom 0.6s;
  animation: animatezoom 0.6s
}

@-webkit-keyframes animatezoom {
  from {-webkit-transform: scale(0)} 
  to {-webkit-transform: scale(1)}
}

@keyframes animatezoom {
  from {transform: scale(0)} 
  to {transform: scale(1)}
}

textarea:invalid {
  border: 2px dashed red;
}

textarea:valid {
   border: 2px solid lime;
}



    .wrapper {
      
      
      cursor: help;
      
      
      
      position: relative;
      text-align: center;
      
      -webkit-transform: translateZ(0); /* webkit flicker fix */
      -webkit-font-smoothing: antialiased; /* webkit text rendering fix */
    }

    .wrapper .tooltip {
      background: #1496bb;
      
      color: #fff;
      display: block;
      left: 0;
      margin-bottom: 1px;
      opacity: 0;
      padding: 10px;
      pointer-events: none;
      position: absolute;
      width: 100%;
      -webkit-transform: translateY(0px);
      -moz-transform: translateY(0px);
      -ms-transform: translateY(0px);
      -o-transform: translateY(0px);
      transform: translateY(0px);
      -webkit-transition: all .25s ease-out;
      -moz-transition: all .25s ease-out;
      -ms-transition: all .25s ease-out;
      -o-transition: all .25s ease-out;
      transition: all .25s ease-out;
      -webkit-box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.28);
      -moz-box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.28);
      -ms-box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.28);
      -o-box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.28);
      box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.28);
    }
    
        /* This bridges the gap so you can mouse into the tooltip without it disappearing */
    .wrapper .tooltip:before {
      bottom: 0px;
      content: " ";
      display: block;
      height: -20px;
      left: 0;
      position: absolute;
      width: 100%;
      
    }
    
        /* CSS Triangles - see Trevor's post */
    .wrapper .tooltip:after {
      border-left: solid transparent 10px;
      border-right: solid transparent 10px;
      border-top: solid #1496bb -10px;
      bottom: 0px;
      content: " ";
      height: 0;
      left: 50%;
      margin-left: -13px;
      position: absolute;
      width: 0;
      
    }
    
        .wrapper:hover .tooltip {
      opacity: 1;
      pointer-events: auto;
      -webkit-transform: translateY(0px);
      -moz-transform: translateY(0px);
      -ms-transform: translateY(0px);
      -o-transform: translateY(0px);
      transform: translateY(0px);
    }

.snow-bg::before {
  content: '';
  width: 400px;
  height: 600px;
  position: absolute;
  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfQAAAH0CAYAAADL1t+KAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QTFCN0Y1NTYyMjczMTFFMUFCRDRFQUNEMjAzMjJFMkQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RkU1MTk3OTQyMjc0MTFFMUFCRDRFQUNEMjAzMjJFMkQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBMUI3RjU1NDIyNzMxMUUxQUJENEVBQ0QyMDMyMkUyRCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBMUI3RjU1NTIyNzMxMUUxQUJENEVBQ0QyMDMyMkUyRCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PhaMNc4AABHpSURBVHja7N3BTlzX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'),
  url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAYAAAB5fY51AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QTFCN0Y1NEUyMjczMTFFMUFCRDRFQUNEMjAzMjJFMkQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QTFCN0Y1NEYyMjczMTFFMUFCRDRFQUNEMjAzMjJFMkQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBMUI3RjU0QzIyNzMxMUUxQUJENEVBQ0QyMDMyMkUyRCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBMUI3RjU0RDIyNzMxMUUxQUJENEVBQ0QyMDMyMkUyRCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Prq/JMMAAAvPSURBVHja7N19bxTX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'),
  url('data:image/png;base64,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');
  background-color: #0000;
  background-repeat: repeat;
  font-family: helvetica, arial, sans-serif;
  animation: snow 60s linear forwards;
  opacity: .5;
}

/* Animation */

@keyframes snow {
  0% {
    background-position: 0 0, 0 0, 0 0;
    opacity: .5;
  }
  500% {
    background-position: 1000px 1000px, 500px 500px, 250px 250px;
    opacity: .5;
  }
  100% {
    background-position: 2000px 2000px, 1000px 1000px, 500px 500px;
    opacity: 0;
  }
}
/* https://github.com/bitwave-tv/bitwave/commit/456c323cf3d90f7f8f2682e507e45c4ddefac3c3 */

 #tags {
     margin-top:2em;
     height:75px;
     width:90%;
     border:1px solid #000;
     font:"serif";
 }
        
    </style>
    
</head>

<body><div class="fixedCookieNotice" style="display: none;">Cookie notice: we may cookies in the future</div> 

<div class="alertArea hide"><textarea id="alerts" placeholder="Pay Pig alerts will be here..." cols="40" rows="20"></textarea></div>
<div class="userlist hide"><ol id="thewatchers"></ol></div>


<div class="dmsArea hide"><textarea id="dms" placeholder="Dms and @&#39;s should show here..." cols="40" rows="20"></textarea></div>
<div class="whispersArea hide"><textarea id="whispers" placeholder="Whispers should show here..." cols="40" rows="20"></textarea></div>

<div id="watchcount" class="labelhelper" onclick="toggleUserList()">On Channel: 0 total: 170</div> <div onclick="toggleDms()" id="ats_count" class="labelhelper">Ats:</div> <div id="whispers_count" class="labelhelper" onclick="toggleWhispers()">Whispers:25</div><div id="alerts_count" class="labelhelper" onclick="toggleAlerts()">Alerts:</div> <div id="lc_count" class="labelhelper">LC:47</div><div id="trollin" onclick="forceTrollNew()" class="labelhelper">Trolln</div>
<div class="maincont">
<div class="labelhelper">
    <!--  has been removed from the list to preven auto channel changing... -->
    <input placeholder="Your username" name="username" type="text" id="userid"><div class="labelhelper">Channel:</div> 
    <select onchange="channelListDropSelectionChanged()" id="channelselect"><option value="beans">beans</option></select><select id="channelselectoffline" style="display: none;"></select><input onchange="messageFilterStateChange(this)" id="filterchatbychannel" type="checkbox" name="Filter Chat to Channel" value="filterchat"><div class="labelhelper wrapper">FM<div class="tooltip">
        Filter Messages
    </div></div><input onchange="trollFilterStateChange(this)" id="filterchattrolls" type="checkbox" name="Filter Chat to Channel" value="filterchattrolls"><div class="labelhelper wrapper" id="parent">TBG<div class="tooltip">
        Troll Be Gone
    </div></div> <input onchange="save_frob()" id="reconnectonblock" type="checkbox" name="Reconnect on Block" value="recononblock"><div class="labelhelper wrapper" id="parent">FROB<div class="tooltip">
        Force Reconnect On Block
    </div></div>
    <input id="connectmepleasedeargod" onclick="disconnectChat()" value="Connect" type="button" class="">
    <input onclick="toggleAvancedButtons()" type="button" value="Advanced">

</div>
<!--<div class="w3-cell-row">-->
<div class="chatWrapper row">
    <!--<div class="w3-container w3-cell"></div>-->
    <div class="column">
        <div id="chat-scroll" class="containment"><!--<div  class="w3-container w3-cell messagesc"> onmouseleave="resumeScroll()"-->
            <div id="chat-scroll" class="messagesc">
                <ol onmouseover="pauseScroll()" id="messageListContainer"> </ol>
            </div>
        </div>
        <!--<div class="w3-container w3-cell">-->
        
       
    </div>
    
    
    <div class="column2 helpers2" style="display: none;">
        <input onclick="showQtroll()" type="button" name="qtroll" value="Qtroll">
         <input onclick="showpoll()" type="button" name="showpoll" value="Show Poll">
        <input onclick="showwhispers()" type="button" name="showwhispers" value="Show Whispers">
        <input onclick="showdms()" type="button" name="showdms" value="Show Dm&#39;s">
        <input onclick="showttsops()" type="button" name="showttsops" value="Show TTS">
        <input onclick="showfallenops()" type="button" name="showfallenops" value="Show Fallen">
        <input onclick="showlogin()" type="button" name="showlogin" value="Show Login">
        <!-- The Modal<input onclick="genBindCode()" value="Gen Bind Code AND COPY" type="button"></input>  -->
        <input onclick="disconnectChat()" value="Disconnect" type="button">
        <input onclick="auth.signOut()" value="Loff" type="button">
        <input id="toggleTrollMode" type="button" name="trollmode" value="Troll Mode" onclick="toggletrollmode()"> <input onclick="clearMessages()" type="button" value="Clear Chat"><input onclick="blurimgs()" type="button" value="Blur">
        <input id="pausechat" onclick="saveAutoScrollSetting()" value="Hover Pause Off" type="button">
        <input type="button" name="refresh" value="Refresh" onclick="getChannelInfo()">
        <!--<input class="hide" id="showViewers" onclick="showViewers()" value="Channel Viewer List" type="button"></input> -->
        <div class="pollArea" style="display: none;">
            <input onclick="hidepoll()" type="button" name="hidepoll" value="Hide Poll"><br>
            <div class="labelhelper">Polls</div>
            <div class="polltitle">Poll:Why do you never see frog penises</div>
            <div class="polloptions" id="pollingid">Poll Options</div>
            <span> should show fun data about polls and their ui</span>
            <!--- looks like i need to put together some start poll ui as well... if one is not running and it is our current channel This is where we should build out and show all of the poll data for when they are active... or if we want to run a poll might make polls into a float/hover type of thing?-->
            <div></div>
        </div>
        
        <div class="qtrollArea">
            <input id="trollid" placeholder="Array goes here" type="text">
            <input type="button" onclick="qtrolllode()" value="Load">
            <input type="button" onclick="qtrollchange()" value="Switch">
        </div>

        <div class="whisperWindow" style="display: none;">
            <input onclick="hidewhispers()" type="button" name="hidewhispers" value="Hide Whispers">
            <br>
            <textarea id="whispers" placeholder="Whispers show up here as text..." cols="40" rows="20"></textarea>
        </div>

        <div class="dmWindow" style="display: none;">
            <input onclick="hidedms()" type="button" name="hidedms" value="Hide Dm&#39;s">
            <br>
            <textarea id="dms" placeholder="Dms show up here as text..." cols="40" rows="20"></textarea>
        </div>
        <div class="ttsOptions" style="display: none;">
            <input onclick="hidettsoptions()" type="button" name="hidetts" value="Hide TTS">
            <div id="tts Options" class="labelhelper">TTS:</div>
            <!-- show some selection options for the tts voice and other bits that we want to configure for tts -->
            <select id="voiceselect"><option value="Microsoft David - English (United States)">Microsoft David - English (United States)</option><option value="Microsoft Mark - English (United States)">Microsoft Mark - English (United States)</option><option value="Microsoft Zira - English (United States)">Microsoft Zira - English (United States)</option><option value="Google Deutsch">Google Deutsch</option><option value="Google US English">Google US English</option><option value="Google UK English Female">Google UK English Female</option><option value="Google UK English Male">Google UK English Male</option><option value="Google español">Google español</option><option value="Google español de Estados Unidos">Google español de Estados Unidos</option><option value="Google français">Google français</option><option value="Google &#2361;&#2367;&#2344;&#2381;&#2342;&#2368;">Google &#2361;&#2367;&#2344;&#2381;&#2342;&#2368;</option><option value="Google Bahasa Indonesia">Google Bahasa Indonesia</option><option value="Google italiano">Google italiano</option><option value="Google &#26085;&#26412;&#35486;">Google &#26085;&#26412;&#35486;</option><option value="Google &#54620;&#44397;&#51032;">Google &#54620;&#44397;&#51032;</option><option value="Google Nederlands">Google Nederlands</option><option value="Google polski">Google polski</option><option value="Google português do Brasil">Google português do Brasil</option><option value="Google &#1088;&#1091;&#1089;&#1089;&#1082;&#1080;&#1081;">Google &#1088;&#1091;&#1089;&#1089;&#1082;&#1080;&#1081;</option><option value="Google &#26222;&#36890;&#35805;&#65288;&#20013;&#22269;&#22823;&#38470;&#65289;">Google&nbsp;&#26222;&#36890;&#35805;&#65288;&#20013;&#22269;&#22823;&#38470;&#65289;</option><option value="Google &#31908;&#35486;&#65288;&#39321;&#28207;&#65289;">Google&nbsp;&#31908;&#35486;&#65288;&#39321;&#28207;&#65289;</option><option value="Google &#22283;&#35486;&#65288;&#33274;&#28771;&#65289;">Google &#22283;&#35486;&#65288;&#33274;&#28771;&#65289;</option></select>
            <input onclick="useSelectedVoice()" type="button" name="selectVoice" value="Use Voice">
            <input onclick="toggleTTSsayName()" type="button" name="toggleReadNames" value="Read Names">
        </div>
        <div class="fallenOptions" style="display: none;">
            <input onclick="hideFallenOptions()" type="button" name="hidethefallen" value="Hide The Fallen">
            <div id="fallenOptionsText" class="labelhelper">Fallen:</div>
            <!-- show some selection options for the tts voice and other bits that we want to configure for tts -->
            <select id="fallenselect"> 
                <!---<option value="MarkPugner">MarkPugner</option>-->
            </select>
            <input onclick="forgiveSelectedFallen()" type="button" name="forgiveFallen" value="Forgive Them">
        </div>
        
        <div class="watchingList" style="display: none;">
        <input onclick="hideWatchersList()" type="button" name="hidewatchlist" value="Hide Watch List">
            <div>
                <ol id="thewatchers2"> </ol>
            </div>
        
        </div>
    </div>
    
    

</div>

<!-- The Modal -->
<div id="id01" class="modal">
  <span onclick="document.getElementById(&#39;id01&#39;).style.display=&#39;none&#39;" class="close" title="Close Modal">×</span>

  <!-- Modal Content action="/action_page.php"-->
  <div class="modal-content animate">
    <div class="imgcontainer">
      <img src="./bw.rnih.org_files/37f0cc752000955_300300" alt="Avatar" class="avatar">
    </div>

    <div class="container">
      <label for="uname"><b>Email</b></label>
      <input type="text" placeholder="Enter Email" name="uname" required="">

      <label for="psw"><b>Password</b></label>
      <input type="password" placeholder="Enter Password" name="psw" required="">

      <button onclick="doLogon()">Login</button>
      <label>
        <input type="checkbox" checked="checked" name="remember"> Remember me
      </label>
      
    </div>

    <div class="container" style="background-color:#f1f1f1">
      <button type="button" onclick="document.getElementById(&#39;id01&#39;).style.display=&#39;none&#39;" class="cancelbtn">Cancel</button>
      <span class="psw">Forgot <a href="https://bw.rnih.org/litechat/#">password?</a><label name="lerror"></label></span>
    </div>
  </div>
</div>

<div id="id03" class="modal">
    <span onclick="document.getElementById(&#39;id03&#39;).style.display=&#39;none&#39;" class="close" title="Close Modal">×</span>
    <div class="modal-content animate">
        <label>Litechat might break soon, but it should be back soon after it breaks... Also makes use of cookies if you use the sign on feature</label>
    </div>
</div>

<div class="chatHelpers">
    <textarea minlength="1" maxlength="300" onmouseover="resumeScroll()" placeholder="Type here to send a message" id="message" cols="40" rows="6"></textarea> 
    <input onclick="send()" value="Send" type="button"><input id="toggleTTS" onclick="toggletts()" value="Turn On TTS" type="button"><input id="toggleNotify" onclick="togglenotify()" value="Turn Off Notify" class="hide" type="button"><input id="toggleAFK" onclick="toggleAFK()" value="Turn On AFK" class="hide" type="button">
    <input id="chatBinder" class="hide" placeholder="ChatBindingCode" type="text">
    <input class="hide" onclick="sendPremium()" value="Premium™" type="button"><input id="playlistitem" placeholder="Url to play" type="text"><input onclick="addtoplaylist()" value="Add To Playlist Bot" type="button"><input type="button" onclick="silence()" value="Silence?">
    <input type="button" onclick="startPL()" value="Start PL">
</div>

</div>
<a href="https://bw.rnih.org/litechat/litechathelp.html">Help and FAQ</a>
<a href="https://www.global-mind.org/gcpdot/">DOT Status</a>

<a href="https://earthquaketrack.com/recent">world quake map</a>

<a href="https://a8silo.com/launch.html#">I-Condom</a><a href="https://emojipedia.org/pile-of-poo/">Emoji</a><a href="https://bw.rnih.org/litechat/?layer-name=Lite%20Chat">OBS</a>
<audio autoplay="false" id="audio2" preload="none" src="" muted=""></audio>
<audio autoplay="false" id="audio3" preload="none" src="" muted=""></audio>

<div>
<textarea minlength="1" maxlength="30000" onmouseover="resumeScroll()" placeholder="Channel goes here" id="darkChannel" cols="40" rows="2"></textarea>
<input type="button" onclick="hop()" value="Hop"><input id="darkbutton" onclick="darkButton()" value="???" type="button">
<input id="spamm" onclick="spamM()" value="Spam" type="button">
<input id="spammhop" onclick="spamMHop()" value="Spam Hop" type="button">
<input id="spamstop" onclick="spamMStop()" value="Spam Stop" type="button">
</div>
<div>
<textarea minlength="3" maxlength="20" placeholder="delay" id="spamDelay" cols="8" rows="1"></textarea>
</div>

<script>
// <div class="w3-container w3-cell"><textarea placeholder="No Messages yet...." id="messages" cols=40 rows=25></textarea></div>
// <div class="w3-container w3-cell"></div>

    /*    
        <div class="ui-widget" style="margin-top:2em; font-family:Arial">
  Result:
  <div id="log" style="height: 200px; width: 300px; overflow: auto;" class="ui-widget-content"></div>
</div>
https://api.jqueryui.com/autocomplete/
    
    https://jqueryui.com/autocomplete/#remote
    function log( message ) {
            $( "<div>" ).text( message ).prependTo( "#log" );
            $( "#log" ).scrollTop( 0 );
        }

        $( "#message" ).autocomplete({
            source: emotes_obj,
            minLength: 2,
            select: function( event, ui ) {
                log( "Selected: " + ui.item.value + " aka " + ui.item.id );
            }
        });
        
        https://github.com/bitwave-tv/bitwave/blob/dev/components/Chat/ChatMessages/ChatMessage.vue line 207 htags and css sizes
        make gifs https://northeastofnorth.com/how-to-make-a-gif-using-gimp-software/
*/


function silence(){
    // open a target to the channel for video
    var chaturl = 'https://bw.rnih.org/video/';
    // get the user name and nave to the channel
    const selected_channel = "";//$( "#channelselect option:selected" ).text();
    window.open(chaturl+selected_channel,'_blank');
}

"use strict";
var socket = null;

var whisperSocketServer = null; // this is how we can whipser since someone can't fix their own version of whispers
whisperSocketServer = io('wss://bw.rnih.org:8088',{transports: ['websocket'] } ); //socket

var advancedShowing = true;

var measured_previous_height = 0;// used to do check to see if it should snap to bottom, have it check and scroll down every so often...?

var activeUserProfile = null;

var recaptchat = null;

var fatchatemotes = [];


var do_ignore = true;

function getfce(){
    try{
            $.get('https://api.bitwave.tv/v1/emotes', function(data, status){
                const emotes_obj =  data;//JSON.parse(data)
                for(var item of Object.keys(emotes_obj.data)){
                    const uaci = emotes_obj.data[item].label;
                    //console.log("Loaded emote: ", uaci);
                    // should store the emotes after they have been loaded
                }
            });
    }catch(ex){

    }
        
    
}
//getfce();
//var userlist_auto = new Set();
var userlist_auto = ["MarkPugner","troll:1488","troll:2222"].map(v => v. toLowerCase()); 

//userlist_auto.add("MarkPugner");

// $("#message").asuggest(userlist_auto, {
//         'minChunkSize': 0,
//         'delimiters': '@\n',
//         'autoComplete': true,
//         'cycleOnTab': true
//     });
function autocompleter(){
    //console.log("changed and needs to recheck the auto suggestions for chat input");
    // should store a user list that it tries to match
    
    // https://jsfiddle.net/prgtrdr/pTt2L/
    
    // Helper functions
		function split(val) {
			return val.split( /,\s*/ );
		}

		function extractLast(term) {
			return split(term).pop();
		}
    
    
    // get the user list and then update it
    
    userlist_auto = ["MarkPugner","troll:1488","troll:2222"].map(v => v. toLowerCase()); 
    console.log("loading autocomplete data");
    try{
        $.get('https://chat.bitwave.tv/v1/users', function(data, status){
            //console.log('trying to get user list')
            //console.log(data);
            
            // bitwave autocomplete uses a few sources of auto complete:
            // emotes
            // user list
            // commands
            
            // probably life the bitwave autocomplete methods
            // https://github.com/bitwave-tv/bitwave/blob/dev/components/Chat/ChatInput.vue
            
            //const channelinfo_str = JSON.stringify(data, null, 4)
            //console.log(channelinfo_str);
            console.log("should parse user list result");
            const channel_info_obj =  data;//JSON.parse(data)
            //console.log("should be after the parse event");
            //console.log(channel_info_obj['success']);
                userlist_auto = [];
                for(var item of Object.keys(channel_info_obj.data)){
                    const uaci = channel_info_obj.data[item].data.username;
                    
                    //console.log(uaci);
                    
                    userlist_auto.push(uaci);
                }
                
            userlist_auto = userlist_auto.map(v => v. toLowerCase()); 
            console.log("we now have: ", userlist_auto.length, " items that can be auto completed");
//             $("#message").asuggest(userlist_auto, {
//                     'minChunkSize': 0,
//                     'delimiters': '@\n',
//                     'autoComplete': true,
//                     'cycleOnTab': true
//                 });


           
            
//             var options = {
//                 data: userlist_auto
// 
//             };
//             
//             $('#message').easyAutocomplete(options);
                // so yeah make a shitty auto suggest for name completion or something...
                
                var tagState = userlist_auto;
                
//                 $("#message")// Create the autocomplete box
//                                 .autocomplete({
//                                     minLength : 0,
//                                     autoFocus : true,
//                                     source : function(request, response) {
//                                     // Use only the last entry from the textarea (exclude previous matches)
//                                         lastEntry = extractLast(request.term);
// 
//                                         var filteredArray = $.map(tagState, function(item) {
//                                             if (item.indexOf(lastEntry) === 0) {
//                                                 return item;
//                                             } else {
//                                                 return null;
//                                             }
//                                         });
//                                     // delegate back to autocomplete, but extract the last term
//                                         response($.ui.autocomplete.filter(filteredArray, lastEntry));
//                                     },
//                                     focus : function() {
//                                         // prevent value inserted on focus
//                                         return false;
//                                     },
//                                     select : function(event, ui) {
//                                         var terms = split(this.value);
//                                         // remove the current input
//                                         terms.pop();
//                                         // add the selected item
//                                         terms.push(ui.item.value);
//                                         // add placeholder to get the comma-and-space at the end
//                                         terms.push("");
//                                         this.value = terms.join(", ");
//                                         return false;
//                                     }
//                                 }).on("keydown", function(event) {
//                                     // don't navigate away from the field on tab when selecting an item
//                                     if (event.keyCode === $.ui.keyCode.TAB /** && $(this).data("ui-autocomplete").menu.active **/) {
//                                         event.preventDefault();
//                                         return;
//                                     }
//                                     
//                                     			// Code to position and move the selection box as the user types
//                                         var newY = $(this).textareaHelper('caretPos').top + (parseInt($(this).css('font-size'), 10) * 1.5);
//                                         var newX = $(this).textareaHelper('caretPos').left;
//                                         var posString = "left+" + newX + "px top+" + newY + "px";
//                                         $(this).autocomplete("option", "position", {
//                                             my : "left top",
//                                             at : posString
//                                         });
//                                     });
                                        

        });// end of get request
        
    }catch(err){
        console.log("error setting up autocompletion");
    }
    // https://api.bitwave.tv/api/channel/markpugner
    //userlist_auto.add("MarkPugner");
    

}    

function toggleUserList(){
    // toggles the class to hide/ show the user list overlay
    $(".userlist").toggle();
    // <ol id="thewatchers"> </ol>
}

function toggleDms(){
    // toggles the class to hide/ show the user list overlay
    $(".dmsArea").toggle();
    // <ol id="thewatchers"> </ol>
}

function toggleWhispers(){
    // toggles the class to hide/ show the user list overlay
    $(".whispersArea").toggle();
    // <ol id="thewatchers"> </ol>
}
    
//autocompleter();
//userlist_auto = ['bob'];
//console.log('fuck recaptucha');

// https://fearandloading.github.io/zero-two-bot/ 

// https://www.groundzeromedia.org/12-6-19-the-quantum-boy-scout-w-jason-quitt/?fbclid=IwAR3xX-CzvQnsWmfOKhS5nPYNHjIKt1p1y4qra7fVG-yfR2q8G1yJT0lGPuU

// diy mail https://mail.cock.li/

// curl -X GET "https://chat.bitwave.tv/v1/messages" -H "accept: application/json"

// many krus https://imgur.com/a/ET4QobV

function gcpt(token){
console.log(token);

}

/*
grecaptcha.ready(function() {
            grecaptcha.execute('6LcEX8QUAAAAADjiUPfbzkyn0KYAaEK263quzCGh', {action: 'litechat'}).then(function(token) {
            recaptchat = token;
        })
});
            

function ReCaptchaCallbackV3(){


    grecaptcha.ready(function() {
        //grecaptcha.execute('6LcEX8QUAAAAADjiUPfbzkyn0KYAaEK263quzCGh', {action: 'litechat'}).then(function(token) {
        //activeUserProfile.recaptcha = rtoken; // set our recaptcha
        //activeUserProfile.recaptcha = rtoken;
        //console.log('Recaptoken:',token);
        //console.log(token);
        
            grecaptcha.execute('6LcEX8QUAAAAADjiUPfbzkyn0KYAaEK263quzCGh', {action: 'litechat'}).then( token => {console.log('should have done stuff...',token)} )
        console.log("what the fuck good is recaptcha if it doesn't even work as expected....");
        //return recaptcha;
        //});
    });
}*/

// Make a CSS thing do the :bitwave: animation in css
// the dual and triple feed, Local, filtered, raw

// https://bitwave-emotes.neocities.org/

// super chat UI would be nice for alerts to mark them as read to hide them


//console.log('fuck recaptucha');
// would be nice to add dot support <iframe src="https://global-mind.org/gcpdot/gcp.html" height="48" width="48" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" ></iframe>


// should add a custom away message box when afk enabled to send back to the users

// should have a chat bind feature so you can post a bind message and use it to bind to your user profile automatically based on the keydisplayed after you post it in chat
// should show when special stuff it toggled on or off for special settings
// should save your session info

// bind chat via a gen bind string, copy to chat and post in bitwave chat
// the client will auto bind to that profile that posts it

// decode the crypto from the messages if they are encrypted

// link scraper

// have a channel select list

// have a filter to channel option

// name complete suggestions
// hover mouse over chat to pause chat messages scrolling THIS IS VERY NICE AND DONE

// select notification sound and level option

// tts cancel toggle
// config tts options

// look at image load events to scroll to bottom

// hi internet traveler: https://www.youtube.com/channel/UCcYo5uLe5T4L2ytK4AAba6A
// https://loveeevee.github.io/Dots-Converter/retro.html

// afk message queue, holds a list of messages until you mark youself as back, should use local storage

// need to update rebind the chat client when the name is changed....

// might be fun to add a raremote feature for emotes that have multiple version like riker, kitty, ralph,etc

// no you https://imagemacros.wordpress.com/2009/06/19/no-u/

// add more controls for the playlistbot to make it easier to add to the playlist and start the playlist

// filter online user list

// whisper messages window

// direct @s window to view messages and store them until deleted/cleared, clear all messages, delete the one

// would be nice to have accurate view / chat counts let channel  = user.page ? user.page.watch || user.page : 'global' ;

// would be nice to have a ignore list that can be shown in a side pane (like polls and whispers, etc)

// https://imgur.com/a/PFxfYC1 dispatch in a dress

// adding checksums might be a good idea...

// hook tube: https://hooktube.com/watch?v=fcbnuHlulgg

// require more vespian gas: https://vocaroo.com/i/s1434uW3Xhc8
// more sounds for starcraft sound board fun https://www.hazmatt.net/gaming/starcraft/index.html

// kitty: delete me bro: https://imgur.com/a/UVNH4GX https://imgur.com/a/dhMTRo0 https://imgur.com/a/9RbApsx https://imgur.com/0jVDdSb

// https://github.com/ipfs/js-ipfs
// https://github.com/ipfs/js-ipfs/tree/master/examples/circuit-relaying
// https://github.com/ipfs/js-ipfs/tree/master/examples/browser-readablestream
// https://github.com/ipfs/js-ipfs/tree/master/examples#js-ipfs-examples-and-tutorials

// https://imgur.com/a/W2aHGfi krueife posts
// thrilled kitty: https://imgur.com/y8zsCN9
// spooknatra https://www.bitchute.com/video/UlNWgAcruk3u/
// no bully kitty https://www.bitchute.com/video/AnKmDeit5kmB/
// neat https://www.iskn.co/
// buddy list would be nice
// also being able to see who is in the channel would be nice for one click at's

// tippy tappy https://soundcloud.com/user-30508968/tippytappy

// https://kittystyle.tv/
// rtmp://31.220.49.162/live/test

// https://www.moefactz.com/

// neeeeeegars https://afreecatv.com/

// no lemon posting https://pastebin.com/PuenwcRZ
// look at something like the marbel game https://pixelbypixelcanada.com/game.html https://pixelbypixelcanada.com/mos.html

// need some jordan: https://notjordanpeterson.com/
// share audio https://vocaroo.com/
// https://vocaroo.com/i/s1GaFhERide2
// https://streamable.com/
// https://www.nimo.tv/download/nimotv

// just eat the starch https://vocaroo.com/i/s1fwzTANaVeR
// hello bitwave https://vocaroo.com/i/s0HdhtOh8CKT
// not jordan https://notjordanpeterson.com/

// dd https://davidduke.com/wednesday190821/
// rip kitty https://i.imgur.com/AGnkE4f.png

// https://github.com/chubin/cheat.sh#usage

// https://vocaroo.com/i/s1SPoLyvB47O

// gotcha spook https://files.catbox.moe/s7508v.png

// blobbies https://pers.com/blobbieworld/cards https://www.youtube.com/watch?v=yvULFXZKgE8

// power slave dos box game https://www.myabandonware.com/game/powerslave-29i/play-29i

// https://www.kvraudio.com/product/dfx_scrubby_by_smart_electronix

// cool streaming effects https://www.movietools.info/

// https://www.nimo.tv/

// https://github.com/trapexit

// https://www.youtube.com/watch?v=HNH61_2bVcA

// https://www.cosmicweenie.com/wealth_tax.pdf

// https://soundcloud.com/vnyl-styl/corntrucks

// https://archive.org/search.php?query=emergency+radio+broadcast&&and[]=year%3A%221980%22&and[]=year%3A%221969%22&and[]=year%3A%221963%22&and[]=year%3A%221943%22&and[]=year%3A%221937%22&and[]=year%3A%221925%22&and[]=year%3A%221903%22&and[]=year%3A%22-1%22&and[]=mediatype%3A%22audio%22

// need to add some escaping of all html in the message that is not span, block, image

// emote dump vnyl: https://imgur.com/a/SEvAyyo
// https://imgur.com/a/EH85j9z
// https://imgur.com/HrbFYXx krusip
// https://imgur.com/a/bCKrHYE
// https://imgur.com/Aiv5Xs3
// https://imgur.com/KVZ2i2c krusmile
// https://imgur.com/Aiv5Xs3
// https://imgur.com/a/clU2F8f
// https://imgur.com/hpipsTq
// pepedj https://chatemotes.neocities.org/85073d10-f1fd-4f19-9a5a-1e2ddd2df82f.gif

// server fuel https://imgur.com/a/60dNdV7

// gloom tube https://youtu.be/t8yB4qL1fAU https://www.youtube.com/channel/UC8dVgSb3C-nqD6h2PpENodA

// https://imgur.com/a/17Js0jd cog pepelaugh https://www.youtube.com/watch?v=DORvF5Mg3dA
// https://imgur.com/a/fdtT08b
// fren https://twitter.com/9fives

// sound cloud https://soundcloud.com/vnyl-styl/dr3aming

// https://www.youtube.com/watch?v=G2x1SfvIbeM drug dev research

// !smol

// https://www.unit-conversion.info/texttools/random-string-generator/
// 1800-444-4444

//https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing

/* broken moderation tools. They do nothing but a kick and a ban button. when they are hit they say " YOU HAVE BEEN KICKED/BANNED" and we laugh and laugh and laugh at the nigger using the buttons
*/

// fancy emotes: fonts-noto-color-emoji 

// https://comparet.christogenea.org/sermons/cainsatanic-seed-line
// https://imgur.com/a/g04Ypj5
// https://imgur.com/a/Ar9qLnA
// https://imgur.com/a/I1p4heu
// https://imgur.com/a/4Xx6e8B
// https://www.minipcdb.com/articles/Meet-Z83II-Mini-PC
// https://github.com/search?q=launchpad+novation 

// susi request line, add a chat option for tts to have the user name read for each message
// make it customizable so it can have the name, says or some type of text ordering and customization for other languages

// check to fix the tts to make sure that it removes the escape characters at the reading point the 39 is the ' character that needs to be escaped and removed from the text

// https://freesound.org/

// loots? https://live.loots.com/c/supersusi87

// https://www.youtube.com/channel/UCxPWH4FoZfAWR0hEzYr253Q

// https://editor.construct.net/
// https://www.construct.net/en/free-online-games/

// https://goose.game/

// https://www.cosmicweenie.com/twitter_overload.pdf

// Special message day, in description, in video and over light chat :^)

// new streaming service found by fren https://www.sliver.tv/

/*
    https://ibb.co/dtZwbnF hitla stickers
    https://ibb.co/VLnVHtg moon dox
    https://imgur.com/cfhIsYn 
    https://ibb.co/4tqqsq7
    https://ibb.co/fqvjW3L
    https://ibb.co/KxrnbWp
    https://ibb.co/GkJzCYv
    https://ibb.co/5GYcFyp
    https://ibb.co/ck2rysZ
    https://ibb.co/KWqH1bL
    https://ibb.co/JRKBSvp
    https://ibb.co/XWsQFdj
    https://ibb.co/sRjLKwY
    https://ibb.co/dtZwbnF
    
    https://lbry.tech/
    https://dyatlovpass.com/
    
    bully nexus https://www.youtube.com/watch?v=dmaobo3EhAY&list=PL9AFFd2foRrDHnuSF_6dOr4bUK6Xt66So&index=16&t=0s
    
    Helene Fischer
    https://www.youtube.com/watch?v=haECT-SerHk
    https://www.youtube.com/watch?v=U0_UYW5Y4cM
    
    carmack talking: 
    https://www.roadtovr.com/oculus-connect-6-john-carmack/
    
    https://www.youtube.com/watch?v=R45UJAlXdFg
    https://teenage.engineering/store
    
    https://www.bitchute.com/video/JICBFmrazFiS/
    
    https://cheekyvideos.net/murdoch/videos/?C=M;O=A
    
    anon payments: https://taler.net/en/
    
    https://www.foxfire.org/
    
    https://www.youtube.com/watch?v=VrtY2lMPiVk
    
    https://twitter.com/JoeLad4/status/1180615353342337025
    
    https://www.anl.gov/
    
    youtube.com/watch?v=CC4nt48IsiE&feature=youtu.be
    
    https://mcafeedex.com/
    
    bivy
    
    dispatch 
    https://www.youtube.com/watch?v=VrtY2lMPiVk

    31.220.49.162:5080/LiveApp/play.html?name=221314240899690440080920
    
    https://www.youtube.com/watch?v=qG2dIdzB8IA
    
    https://cdn.stream.bitwave.tv/rec/
    https://cdn.stream.guntwave.tv/rec/
    
    look at adding hold music support, should be able to check if vlc is up and running as expected or not, and stop the play back of the hold music
    
    should be able to used timed stuff 
    
    void.com https://www.youtube.com/user/voidiov/videos
    
    https://www.youtube.com/user/usnationalarchives/videos
    
    add a reconnect chat message if for some reason it is disconnected...
    
    I think I fixed the text wrapping in chat for long text
    
    #https://medium.com/@Mewsse/file-upload-with-socket-io-9d2d1229494
    file send and recieve should be thought as sync of chunks that we want to send or recieve and use hashes to determine if they have completed or not 
    
    store file names as a list that can be searched or use a file dir that can be searched
    
    then hash the file or the parts and do the chunk transfers
    
    need to request a list of files then be able to request the files names
    
    need to be able to try and search the files (should be done over the other server)
    
    need to use a file hash to request the file, the list will have filename and hash next to it
    
    vnyl emotes https://imgur.com/a/SEvAyyo
    
    gunters mark
    https://i.ibb.co/jGqvF33/gunters-mark.jpg
    
    https://i.ibb.co/HXWk1JL/venti-bleached.jpg
    
    kitty's drunk https://streamable.com/yqdjp
    
    https://cryptome.org/hudsonyards-collateral/index.html
    
    alt site
    https://entropystream.live/#/home
    
    https://www.cyberciti.biz/tips/bash-aliases-mac-centos-linux-unix.html
    
    https://github.com/nanochess/fbird
    https://github.com/nanochess/Pillman/blob/master/pillman.asm
    
    build a ui for https://github.com/alxarsenault/AudioTools
    https://github.com/bbc/brave
    https://github.com/search?q=hlsjs-p2p-engine
    https://github.com/viva64/pvs-studio-makefile-examples/blob/master/example-1/Makefile
    https://github.com/streamlink/streamlink
    https://imgur.com/gallery/C10cZWQ
    
    https://files.catbox.moe/9pxfjq.mp3
    https://files.catbox.moe/92hewb.mp3
    https://files.catbox.moe/pze1hy.mp3
    
    hatebin.com
    
    >MOBILE (763) 614-6919
    >MOBILE (763) 227-2021
    
    10 hours by fear link https://www.youtube.com/watch?v=UlJ9fKe56m8
    
    vidlii.com
    
    moon man https://www.vidlii.com/user/MoonManTheH8rKKTK
    
    https://store.steampowered.com/app/240440/Quadrilateral_Cowboy/
    
    https://kproxy.com/
    
    https://www.blipbillboards.com/
    
    https://docs.median-xl.com/
    https://www.median-xl.com/changelog
    https://airvpn.org/faq/bitcoin/
    https://mullvad.net/en/help/tag/account-and-payments/
    https://store.steampowered.com/app/219990/Grim_Dawn/
    
    https://www.twitch.tv/saltybet/ mugen
    https://www.saltybet.com/
    https://github.com/search?p=2&q=ikemen&type=Repositories
    
    https://parsecgaming.com/
    
    add support for an emoji picker:
    https://github.com/missive/emoji-mart
    https://emojipedia.org/pile-of-poo/
    https://www.101soundboards.com/sounds/586607-ginger-welcome-to-terribles
*/

function blurimgs(){
    // should setup a css for img that enables a blur

}

if ( !firebase.apps.length ) {
  firebase.initializeApp({
    apiKey: "AIzaSyCgIwubBz-nTd0mof6l7eklzJk1evuwzhg",
    authDomain: "bitwave.tv",
    databaseURL: "https://bitwave-7f415.firebaseio.com",
    projectId: "bitwave-7f415",
    storageBucket: "bitwave-7f415.appspot.com",
    messagingSenderId: "246532190856",
  });
}

const auth = firebase.auth();
const db = firebase.firestore();

var trolliddd = -1;

var nh = null;
var lh = null;
var trollidd = ['eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0aFVlIiwiaXNzIjoiaHR0cHM6Ly9hcGkuYml0d2F2ZS50diIsInVzZXIiOnsibmFtZSI6InRyb2xsOjRoVWUiLCJjb2xvciI6ImhzbCggMzIwLCA2NSUsIDU1JSwgMSApIiwidXNlckNvbG9yIjoiIzllOWU5ZSJ9LCJpYXQiOjE2MDgwNzUxNjF9.PYE9lzhDn0Sgezi6F1G3anR4EXLj9CCyHgIU3uCJX4s',
'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ4VU5oIiwiaXNzIjoiaHR0cHM6Ly9hcGkuYml0d2F2ZS50diIsInVzZXIiOnsibmFtZSI6InRyb2xsOnhVTmgiLCJjb2xvciI6ImhzbCggMjgwLCA2MCUsIDUwJSwgMSApIiwidXNlckNvbG9yIjoiIzllOWU5ZSJ9LCJpYXQiOjE2MDgwNzUxNzJ9.HXFplLfZe7D3zvJIOhz41qw0eQ1bxF9MknDHz1AlPFU',
'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0SVFFIiwiaXNzIjoiaHR0cHM6Ly9hcGkuYml0d2F2ZS50diIsInVzZXIiOnsibmFtZSI6InRyb2xsOjRJUUUiLCJjb2xvciI6ImhzbCggMjIwLCA3MCUsIDU1JSwgMSApIiwidXNlckNvbG9yIjoiIzllOWU5ZSJ9LCJpYXQiOjE2MDgwNzUxODR9.5pOzfPJnQiXyP6F-ZInsoETXiPKcY3KM9TWiXErCdc0',
'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ2b3RDIiwiaXNzIjoiaHR0cHM6Ly9hcGkuYml0d2F2ZS50diIsInVzZXIiOnsibmFtZSI6InRyb2xsOnZvdEMiLCJjb2xvciI6ImhzbCggMTIwLCA3NSUsIDUwJSwgMSApIiwidXNlckNvbG9yIjoiIzllOWU5ZSJ9LCJpYXQiOjE2MDgwNzUxOTV9.hJXr6XcqXudDDmL9hiX_v5fTgJadHTttE2GnFAykEL4',
'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJTQlJXIiwiaXNzIjoiaHR0cHM6Ly9hcGkuYml0d2F2ZS50diIsInVzZXIiOnsibmFtZSI6InRyb2xsOlNCUlciLCJjb2xvciI6ImhzbCggODAsIDc1JSwgNTAlLCAxICkiLCJ1c2VyQ29sb3IiOiIjOWU5ZTllIn0sImlhdCI6MTYwODA3NTIwMn0.jbH8josuGNXeo8qNeoImt9uIQ6ME6yooPdILcyln72I'];

var litechat = true;
litechat = false;

function get(name){
   if(name=(new RegExp('[?&]'+encodeURIComponent(name)+'=([^&]*)')).exec(location.search))
      return decodeURIComponent(name[1]);
}



function authenticateFDB(fdbun,fdbpwd){
    try{
    var user_cred = auth.signInWithEmailAndPassword(fdbun, fdbpwd);
    //console.log("authed with:", user_cred.user.displayName, user_cred.user.idToken);
    console.log(user_cred);
    
    // should be able to get: 
    //console.log("signed in as:",user_cred.gt.i.user);
    /*
    body .application { background-color: rgba(0, 0, 0, .2) !important; } #sidechat { background-color: rgba(0, 0, 0, 0) !important; }*/
    
    // should be able to catch the error 
    // code: "auth/user-not-found"
    // message: "There is no user record corresponding to this identifier. The user may have been deleted."
    // should be able to show a failure message
    // should log that we authenticated and then also give us access to sync our ignore list with propper fat chat
    // would also be nice to get the channel ignore option as well
    // and then we can look at storing a buddy list
    // also supporting notificaitons would be nice as well
    document.getElementById('id01').style.display='none';
    }catch(err){
        // should show an error message
        console.log(err);
        // should be able to set the error status from firebase
        $("label[name='lerror']").text("Error: logging in");
    }
}

function showViewers(){
    // un hide the ui and show the user list of people on the channel
    // showViewers
    $(".watchingList").show();
    $("#showViewers").hide();
}

function toggleTTSsayName(){
    read_names = !read_names;

}

function hydrateChat(){
    // should do a get request
    //`https://chat.bitwave.tv/v1/messages${ this.global ? '' : `/${this.page}`
    // https://whatthecommit.com/
    //${ this.global ? '' : `/${this.page}` }
    //let result;
    console.log('called to hydrate chat')
    if($("#filterchatbychannel").prop( "checked" )){
        // get the channel selected info
        const tempchannel = $( "#channelselect option:selected" ).text();
        $.get('https://chat.bitwave.tv/v1/messages/' + tempchannel, function(data, status){
            console.log('trying to hydrate chat local')
            hydrate(data.data);
        });
    }else{
        $.get('https://chat.bitwave.tv/v1/messages', function(data, status){
            console.log('trying to hydrate chat')
            hydrate(data.data);
        });
    }
    /*result = $.ajax({
            url: `https://chat.bitwave.tv/v1/messages`,
            type: 'GET',
        });*/                   
    //return result;
    
}

// https://www.gnu.org/software/librejs/

// https://itnext.io/build-ffmpeg-webassembly-version-ffmpeg-js-part-5-ffmpeg-js-v0-3-pre-js-and-live-streaming-c1498939a74c
// https://github.com/ffmpegwasm/ffmpeg.wasm

// https://petetasker.com/using-async-await-jquerys-ajax/ was used to handle the promis object that needed to be used
async function getChatToken(idToken){
    // const { data } = await this.$axios.post( `https://api.bitwave.tv/api/token`, { token: idToken } );
    console.log("should get the chat token");
    console.log( `ID Token Generated in chat:`, idToken );
    
    let result;
    //console.log(userid);
    //const emotesurl="https://api.bitwave.tv/api/token";
    try{
        //$.post("https://api.bitwave.tv/api/token",{ token: idToken, }, function(data, status){
        result = await $.ajax({
            url: "https://api.bitwave.tv/api/token",
            type: 'POST',
            data: { token: idToken, }
        });
            // we should then be able to get out the chat token and use it for the info to start the connection to chat
            // looks like the correct way is to do a diconnect then refire all of the new connections and listeners?
            //alert("Data: " + result + "\nStatus: " + status);
            // it looks like this works
            //console.log(result);
            //return result;
            
            try{
                // should then try to start the session 
                usertoken = result.chatToken;
                restartConnection();
                console.log("should have connected with our chat token for the user...");
                window.localStorage.setItem('chatToken'  , result.chatToken  );
                
            
            }catch(err){
                console.log(err);
            }
            
            
            //console.log(JSON.stringify(data, null, 4))
            //const emoteinfo_str = JSON.stringify(data, null, 4);
            //console.log(emoteinfo_str);
            
            /*
            console.log("should have a response from the server... for our new token");
            usertoken = data;
            console.log(usertoken);
            console.log('after binding chat token data');
            // then do a reconnect or restart or bindInfo
            try{
                window.localStorage.setItem('usertoken'  , usertoken  );
            }catch(err){
                console.log(err);
            }*/
            // then when we load chat we should try and get our user token and do some baseic validation on it to do a connection
            // 
            
            
        //});
    }catch(err){
        console.log(err);
    }

}

// crow is a nigger https://www.youtube.com/channel/UCTiViMS4ZXaSYysyFE5R5UA

// niggers and their async firebaseauth...

// needs to be async scoped and use await

firebase.auth().onAuthStateChanged(function(user) {
        // [START_EXCLUDE silent]
        //document.getElementById('quickstart-verify-email').disabled = true;
        // [END_EXCLUDE]
        if (user) {
          // User is signed in.
          var displayName = user.displayName;
          //var email = user.email;
          var emailVerified = user.emailVerified;
          var photoURL = user.photoURL;
          var isAnonymous = user.isAnonymous;
          var uid = user.uid;
          var providerData = user.providerData;
          //console.log("we logged in?:",uid,email,displayName);
          const userId = user.uid;
          
          // should get the new user token format and use it for the connection start and store it
          
          const userdocRef = db.collection( 'users' ).doc( userId );
          userdocRef.onSnapshot(async doc => {
          
            const idToken = await auth.currentUser.getIdToken();
            
            // well holy nigger shit that wasn't too bad, just need to tactically add in async + await to get it to wrap those shitty promises and just work
            
            //https://national-justice.com/
            //https://fitgirl-repacks.site/ancestors-the-humankind-odyssey/
            // https://ibb.co/CHFfy3P
            // https://en.wikipedia.org/wiki/Stranger_in_a_Strange_Land
            // https://archive.org/details/j2me-archive-unified-2019-09
            // https://en.wikipedia.org/wiki/The_Moon_Is_a_Harsh_Mistress
            // https://cheekyvideos.net/murdoch/videos/?C=N;O=A
            // impeach45 https://imgur.com/9UH6dVM
            // https://www.youtube.com/watch?v=I90KQRsnRWY
            
            //var idstr = JSON.stringify(idToken);
            //console.log(`ID token Generated in Chat:`, idstr);
            console.log(`ID token Generated in Chat:`, idToken);
            // fuck fuck fuck, this does make it more interesting not using axios to not do this
            //const { data } = await $.post( `https://api.bitwave.tv/api/token`, $.param({ token: idToken }) );
            //console.log("crap we got back: ", data);
            //const chatToken = data.chatToken;
            //console.log( 'Chat Token Exchanged:', chatToken );
            getChatToken(idToken);
            //const chatToken = data.chatToken;
            
            // now we need to set the chat token in the store
            //try{
                // so it's being pissy about this shit, maybe we won't use the jquery version
                /*$.post("https://api.bitwave.tv/api/token",{ token: idToken, }, function(data, status){
                    alert("Data: " + data + "\nStatus: " + status);
                });
            console.log("should get a token using:", idToken);*/
            
            // just save the id and get the chat token at a later point
            
            /*var xhttps = new XMLhttpsRequest();
            xhttps.open("POST", "https://api.bitwave.tv/api/token", false);
            //xhttps.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            xhttps.send({ token: idToken, });
            console.log("Our nice token:" , xhttps.responseText);*/
            /*}catch(err){
                console.log(err);
            }*/
            // fuck it says the call stack is too deep :(
            
            const userd = doc.data();
            console.log(userd);
            console.log("avatar:",userd.avatar);
            
            /*lh = gitfuggedniggerRot13(displayName + userd.avatar);
            try{
                window.localStorage.setItem('lh'  , lh  );
            }catch(err){
                console.log(err);
            }*/
            
            
            
            // should setup and rebind the user to the login stuff that we just did
            //bindInfo(displayName,userd.avatar)
            const ignoreList = doc.get( 'ignoreList' );
            if ( ignoreList !== undefined ) {
                //this.ignoreList = ignoreList;
                console.log("ignore list:",JSON.stringify( ignoreList));
                // should merge and reload the ignore list from the user account to litechat
                //localStorage.setItem( 'ignorelist', JSON.stringify( this.ignoreList ) );
                // do a for each over all of the items in the list
                ignoreList.forEach( ignore_name => {
                    ignore_set.add(ignore_name.toLowerCase());
                    console.log("should add:", ignore_name);
                });
                save_ignores();
                load_ignores();
                rebuildFallenOptions();
                // then load ignores to update it
            } else {
                //await doc.ref.update( 'ignoreList', this.ignoreList );
            }
            
            const ignoreChannelList = doc.get( 'ignoreChannelList' );
            if ( ignoreChannelList !== undefined ) {
                //this.ignoreList = ignoreList;
                console.log("ignoreChannelList list:",JSON.stringify( ignoreChannelList));
                //localStorage.setItem( 'ignorelist', JSON.stringify( this.ignoreList ) );
            } else {
                //await doc.ref.update( 'ignoreList', this.ignoreList );
            }
            
            
          });
          /*const docRef = db.collection( 'users' ).doc( userId ).set({
            _username: username.toLowerCase(),
            uid: userId,
            username: username,
            email: email,
          });*/
          
          // https://www.alanzucconi.com/2018/03/14/introduction-to-deepfakes/
          // https://github.com/deepfakes/faceswap
          // https://cosmicweenie.com/identity.htm
          // https://mega.nz/#F!att02Q7S!0h9ORGR7iRQtJInRaibkAw soundboard 
          
          // this is where we need to setup the user information 
          // [START_EXCLUDE]
          //document.getElementById('quickstart-sign-in-status').textContent = 'Signed in';
          //document.getElementById('quickstart-sign-in').textContent = 'Sign out';
          //document.getElementById('quickstart-account-details').textContent = JSON.stringify(user, null, '  ');
          if (!emailVerified) {
            //document.getElementById('quickstart-verify-email').disabled = false;
          }
          // [END_EXCLUDE]
        }else{
            // do troll based connection start using trolltoken
            //bindInfo(displayName,userd.avatar)
            //restartConnection("");
        }
});



function doLogon(){
    try{
        const email=$("input[name='uname']").val();
        //console.log("email:", email);
        const password=$("input[name='psw']").val();
        //console.log("pass:", password);
        authenticateFDB(email,password);
        // need to then hide the longin if it was successful...
    }catch(err){
        console.log(err);
    }
}

function toggleAlerts(){
    $(".alertArea").toggle();
}

function spamM(){
    window.spamN = setInterval(darkButton, $("textarea#spamDelay").val());
}

function spamMHop(){
    window.spamH = setInterval(hop, $("textarea#spamDelay").val());
}

function spamMStop(){
    clearInterval(window.spamN);
    clearInterval(window.spamH);
}

function darkButton(){
    socket.emit('message',{message:$("textarea#message").val(),channel:$("textarea#darkChannel").val()});
}

function toggleAvancedButtons(){
    if(advancedShowing){
        $(".helpers2").hide();
        advancedShowing = false;
    }else{
        $(".helpers2").show();
        advancedShowing = true;
    }
}
$(".fixedCookieNotice").hide(); // get rid of this when we have cookies

toggleAvancedButtons();


function showlogin(){
    document.getElementById('id01').style.display='block';

}

function showpoll(){
     $(".pollArea").show();
      $("input[name='showpoll']").hide();
}

function showQtroll(){
    // shows new troll input and switch dialog, lets you paste in a new troll token with ease and switch
    // to that new id
    $(".qtrollArea").show();
    // should close the advanced menu
}

function qtrolllode(){
    trollidd = $("#trollid").val().split(',');
    trolliddd = -1;
}

async function qtrollchange(args){
    console.log("args:", args);
    // similar to trolln
    // get the troll id from the box and close the troll area
    // hid the advanced if we didn't do that already
    // reconnect with our new troll id
    trolliddd = trolliddd + 1;
    if (trolliddd == trollidd.length){
        trolliddd = 0;
    }
    disconnectChat();
    /*const result = await $.ajax({
        url: "https://api.bitwave.tv/api/troll-token",
        type: 'GET'
    });*/
    var result = trollidd[trolliddd].replace(/\s+/g,'');
    if(result.length > 0){
    
    }else{
        result = await $.ajax({
            url: "https://api.bitwave.tv/api/troll-token",
            type: 'GET'
        });
    }
    // do a length check and tell them that they are stupid for not putting something in...
    console.log("Qtroll id:", result);
    // get the result as it is in the input box and clear the token?
    //const { data } = await $.$axios.get('https://api.bitwave.tv/api/troll-token');
    console.log('trollidinfo:',result);
    //trollTokenls = result.chatToken;
    console.log(parseToken(result).user.name);
    // destroy the connection to chat and make a new one
    $("#trollin").text(parseToken(result).user.name);
    
    if(socket){
        socket.off('connect');
        socket.off('bulkmessage');
        socket.off('alert');
        socket.off('update usernames');
        socket.off('blocked');
        socket.off('pollstate');
        
        socket.disconnect();
        //socket.destory();
        socket = null;
        console.log(socket)
        console.log("Should have disconnected the socket")
    }
    
    socket = io( 'wss://chat.bitwave.tv', { transports: ['websocket'] } );
        const tempchannel = $( "#channelselect option:selected" ).text();
        
        
    socket.on('connect', () => {
           
            
            //recaptcha = null
            var userTokenObj = {
                    type  : 'user',
                    token:result,
                    page: tempchannel
            }
            socket.emit('new user', userTokenObj);
            // show a connected message
            //$("#connectmepleasedeargod").toggleClass("hide");
            console.log("Connecting to chat... as a new troll id");
            if(args == "close"){
                toggleAvancedButtons();
            }
            // add message
        });
        
        socket.on( 'bulkmessage', async data => await this.rcvMessageBulk(data) );
        
        socket.on( 'alert', async data => await this.addAlert(data) );

        socket.on( 'update usernames', async data => await this.updateUserWatchInfo(data) );

        socket.on( 'blocked',   data => messageBlocked(data)  ); // shoves the message back into the send buffer
        socket.on( 'pollstate', data => updatePoll(data) );

}

function showwhispers(){
    $(".whisperWindow").show();
    $("input[name='showwhispers']").hide();
}

function showdms(){
    $(".dmWindow").show();
     $("input[name='showdms']").hide();
}

function showttsops(){
    $(".ttsOptions").show();
    $("input[name='showttsops']").hide();

}

function hidepoll(){
    $(".pollArea").hide();
    $("input[name='showpoll']").show();
}

function hidewhispers(){
    $(".whisperWindow").hide();
    $("input[name='showwhispers']").show();
}

function hidedms(){
    //$("hide").click(function(){
        $(".dmWindow").hide();
         $("input[name='showdms']").show();
    //});
}

function hidettsoptions(){
    $(".ttsOptions").hide();
    $("input[name='showttsops']").show();
}

function hideFallenOptions(){
     $(".fallenOptions").hide();
    $("input[name='showfallenops']").show();
}

function showfallenops(){
    $(".fallenOptions").show();
      $("input[name='showfallenops']").hide();
    // rebuild the display list of the fallen
    rebuildFallenOptions();
}

function useSelectedVoice(){
    //vSelected = selected option text
    vSelected = $( "#voiceselect option:selected" ).text();
    // call the save tts settings
    save_tts_settings();
}

function hideWatchersList(){
    $(".watchingList").hide();
    $("#showViewers").show();
    $("input[name='hidewatchlist']").show();
}


hidedms();
hidewhispers();
hidepoll();
hidettsoptions();
hideFallenOptions();
hideWatchersList();


var username = "troll";
var channel = "markpugner";

subscribeToPoll (channel);

var emotes_obj = null;

var ignore_set = new Set();

var ignore_ch_set = new Set();

var vlist = null;

var vSelected = '';

var dms = [];
var ats = [];

var alerts = [];

// maybe do a channel set? so we can do a auto de dupe?

var channels = new Set();

var forceScrollToBottom = false;

var frens = []; // the friend list

var channel_users = [];

var qty_target_msgs = 100;

var default_message = "kkg is a insufferable faggot";

var no_emotes = false;


function setStreamMode(){
    // should detect the url setting via hidden text box
    const val = get('streamMode');
    
    const chanval = get('channel');
    
    
    const noemotesplox = get('noemotesplox');
    if(noemotesplox){
        no_emotes = true;
    }
    
    const chanonlyval = get('channelOnly');
    
    chatFeatureNotify = false;
    
    const kkg_is = get('kkg');
    if(kkg_is == 'a_huge_seething_faggot'){
        // allow send or setup a default message of kkg is a insufferable faggot
        default_message = "";
    }
    
    default_message = "";
    
    
    const chat_len = get('chatLength');
    
    const read_chat_with_names = get('readChatWithNames');
    if(read_chat_with_names){
        toggleTTSsayName();
    }
    
    if( chat_len){
        qty_target_msgs = chat_len;
        console.log("setting extended custom chat length:", chat_len);
    }
    
    if(chanonlyval == "true"){
        // filter down to the channel
        $("#filterchatbychannel").prop( "checked",true ) ;
        //$("#filterchattrolls").prop( "checked",true ) ;
        //console.log()
        
    }
    
    if(chanval){
        channel = chanval;
        addChannel(chanval);
        $( "#channelselect option:selected" ).text(channel);
        console.log("Filter to channel:", channel);
    }
    // sets the css settings for stuff
    if( val == "true"){
        $("body").css("background-color","rgba(0, 0, 0, .2)");
        $("div.messagesc").css("background-color","rgba(0, 0, 0, .2)");
        // hide the ui top 
        $("div.labelhelper").hide();
        // hide the ui entry crap
        $("div.chatHelpers").hide();
        $("div.grecaptcha-badge").hide();
        
        $("div.containment").css("height","90%");
        $("div.messagesc").css("height","100%");
        $("div.messagesc").css("max-height","100%");
        $("ol").css("height","100%");
        /*div.containment{
            height:600px;
        
        }
         should also strip ul li things out of messages
        div.messagesc{
         background-color:#0f0f0f;
         background-color:#000000;
         height: 600px;
         width:475px;
         color:#cfcfcf;
         max-height: 600px;
         
        }*/
        
        // would be nice to set a custom chat height
        
        // should force to bottom
        forceScrollToBottom = true;
        resumeScroll();
    }
     //body .application { background-color: rgba(0, 0, 0, .2) !important; } #sidechat { background-color: rgba(0, 0, 0, 0) !important; }
}

setStreamMode();



var userProfile = {
    avatar: null,
    username: username,
    page: channel,
color:null,
userColor: "#55aa7f"
}

var usertoken = null;
var trolltoken = null;

function disconnectChat(){
    if(socket){
        if(socket.connected){
            socket.disconnect();
        }else{
            socket.open();
            restartConnection();
        }
    }
}

function forgiveSelectedFallen(){
    // removes the person from the fallen ignore list that is selected
    vSelected = $( "#fallenselect option:selected" ).text();
    // remove them from the ignore list
    add_remove_to_ignore(vSelected.toLowerCase());
    rebuildFallenOptions();
}

function rebuildFallenOptions(){
    const selected_channel = $( "fallenselect option:selected" ).text();
        $('#fallenselect').empty();// clear the list and add the new options back in
        
        for (var it = ignore_set.values(), val= null; val=it.next().value; ) {
            console.log(val);

//        for( channel in ignore_set){
            //console.log(channel[channel].name);
            //console.log(channel[channel].title);
            //console.log(channel[channel].url);
            //const chname = ignore_set[channel];
            //const churl = channel_info_obj.users[channel].url;
            //const chlive = channel_info_obj.users[channel].live;
            //console.log(chname);
            //console.log(churl);
            
            //if(chlive ){
                $('#fallenselect').append('<option value="' + val + '">' + val + '</option>');
            //}
        }
        
        
}

function load_tts_settings(){
    try{
       var tts_settings_string =  window.localStorage.getItem('tts_settings');
    
        // try to restore the object from the string
       var tts_settings_obj  = JSON.parse(tts_settings_string);
       
       //ignore_set = new Set(ignore_list);
       vSelected = tts_settings_obj.voice;
       // should set the selection 
       $( "#voiceselect option:selected" ).text(vSelected)
    
    }catch(err){
        console.log("error loading tts settings");
    }
    
}

function save_tts_settings(){
    try{
        //var ignore_list = Array.from(ignore_set);
        var tts_settings = {
            'voice':vSelected
        };
        var myJSON = JSON.stringify(tts_settings);
        window.localStorage.setItem('tts_settings'  , myJSON  );
    }catch(err){
        console.log("error saving tts settings");
    
    }
}

function load_ignores(){
    //ignore_set = stuff in storage
    try{
       var ignore_string =  window.localStorage.getItem('ignore_set');
       
    
        // try to restore the object from the string
       var ignore_list  = JSON.parse(ignore_string);
       
       
       ignore_set = new Set(ignore_list);
       
       var ignore_ch_string =  window.localStorage.getItem('ignore_ch_set');
       var ignore_ch_list  = JSON.parse(ignore_ch_string);
       ignore_ch_set = new Set(ignore_ch_list);
    
    }catch(err){
        console.log("error loading ingore set");
    }

}

function save_ignores(){
    
    try{
        var ignore_list = Array.from(ignore_set);
        var myJSON = JSON.stringify(ignore_list);
        window.localStorage.setItem('ignore_set'  , myJSON  );
        
        var ignore_ch_list = Array.from(ignore_ch_set);
        var myJSON = JSON.stringify(ignore_ch_list);
        window.localStorage.setItem('ignore_ch_set'  , myJSON  );
        
    }catch(err){
        console.log("error saving ingore set");
    
    }
}

function load_frob(){
    // $("#reconnectonblock").prop( "checked" )
    try{
        var ignore_string =  window.localStorage.getItem('frob');
        if(ignore_string == 'true'){
            //$("#reconnectonblock").prop( "checked" ) = true;
            $("#reconnectonblock").prop( "checked",true )
            console.log("Should have loaded the frob value of:", ignore_string);
        }
    }catch(err){
        console.log("Should have loaded the frob value:",err);
    }
}

load_frob();

// call this when the value changes
function save_frob(){
    //window.localStorage.setItem('ignore_ch_set'  , myJSON  );
    
    if($("#reconnectonblock").prop( "checked" )){
        window.localStorage.setItem('frob'  , true  );// user id
    }else{
        window.localStorage.setItem('frob'  , false  );// user id
    }
    
}

function add_remove_to_ignore(ignore_name){
    // check if it is already in the set,
    // if it is remove it
    if(is_user_ignored(ignore_name)){
        ignore_set.delete(ignore_name.toLowerCase());
        console.log("removing user to ignore list:" + ignore_name);
    }else{
        
        // if it isn't push/add it
        ignore_set.add(ignore_name.toLowerCase());
        console.log("adding user to ignore list:" + ignore_name);
    }
    console.log("Ignore list size: " + ignore_set.size );
    
    save_ignores();
    load_ignores();
}


function add_remove_to_ch_ignore(ignore_name){
    // check if it is already in the set,
    // if it is remove it
    if(is_ch_ignored(ignore_name)){
        ignore_ch_set.delete(ignore_name.toLowerCase());
        console.log("removing user to ignore list:" + ignore_name);
    }else{
        
        // if it isn't push/add it
        ignore_ch_set.add(ignore_name.toLowerCase());
        console.log("adding user to ignore list:" + ignore_name);
    }
    console.log("Ignore list size: " + ignore_set.size );
    
    save_ignores();
    load_ignores();
}

function is_user_ignored(name_to_check){
    // check if the user is in the ignore set 
    if(ignore_set != null && ignore_set.size > 0){
        var is_user_in_set = ignore_set.has(name_to_check.toLowerCase());
        //console.log('checking for user:' + name_to_check);
        //console.log('found:'+is_user_in_set);
        return is_user_in_set;
    }else{
        return false;
    }

}

function is_ch_ignored(name_to_check){
    // check if the user is in the ignore set 
    if(ignore_set != null && ignore_ch_set.size > 0){
        var is_user_in_set = ignore_ch_set.has(name_to_check.toLowerCase());
        //console.log('checking for user:' + name_to_check);
        //console.log('found:'+is_user_in_set);
        return is_user_in_set;
    }else{
        return false;
    }

}

load_ignores();

function clearMessages(){
    const qty_target = 0;
    const counted = $("#messageListContainer div").length;
    //console.log("Counted:", counted);
    //console.log("");
    if(counted > qty_target){
        const amount_to_remove = counted - qty_target;
        $('#messageListContainer').find("div").slice(0, amount_to_remove).remove();
        console.log("removed:", amount_to_remove)
    }

}

function parseToken (token) {
    try{
        var base64Url = token.split('.')[1];
        var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        var jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
    }catch(ex){
        console.log("failed to parse the token")
        return {user:{name:'failed'}}
    }
    return JSON.parse(jsonPayload);
};

//import socketio from 'socket.io-client' ;
console.log("before init of the socket client");

//this.socket = io( 'wss://chat.bitwave.tv', { transports: ['websocket'] } ); //socket
//this.socket.on( 'connect', () => this.socket.emit('new user', userProfile) );
//this.socket.on( 'update usernames', async data => await this.updateViewerlist(data) );

// try and restore the id from the localStorage if it exists
var forceTrollMode = false;
async function makeTrollID(){

    /*try{
        forceTrollMode   = window.localStorage.getItem('forcetrollmode');
    
    }catch(err){
        forceTrollMode = true;
    }*/

    try{
        lh = window.localStorage.getItem('lh');
    
    }catch(err){
        lh = null;
    
    
    }

    try{
        var filterval = window.localStorage.getItem('filterchatbychannel');
        if(filterval == 'true'){
            filterval = true;
        }else{
            filterval = false;
        }
        $("#filterchatbychannel").prop( "checked",filterval ) ;
    
    }catch(err){
        console.log("failed to restore channel filter mode setting");
    
    
    }
    
    try{
        
        var filterval = window.localStorage.getItem('filterchattrolls');
        if(filterval == 'true'){
            filterval = true;
        }else{
            filterval = false;
        }
        $("#filterchattrolls").prop( "checked",filterval ) ;
    }catch(err){
    
    }
    
    // get our scroll status
    try {
        forceScrollToBottom   = window.localStorage.getItem('forceScrollToBottom');
        //let color = window.localStorage.getItem('tcolor');
        if(forceScrollToBottom == 'true'){
            forceScrollToBottom = true;
        }else{
            forceScrollToBottom = false;
        }
        window.localStorage.setItem('forceScrollToBottom'  , forceScrollToBottom  );
        
    }catch(err){
        // caught storage error most likely
        forceScrollToBottom = false; // this defaults us to always stay at bottom and not turn off scroll when chat is hovered
        //restartConnection(userProfile);
    }
    
    setScrollPauseForceState();
    

    if(true){
            try {
                /*let uid   = window.localStorage.getItem('tuid');
                let color = window.localStorage.getItem('tcolor');
                if (!uid || !color) {
                uid   = [...Array(4)].map(() => (~~(Math.random()*36)).toString(36)).join('');
                color = `hsl( ${Math.round(256 * Math.random())},75%,50%,1)`;
                window.localStorage.setItem('tuid'  , uid  );
                window.localStorage.setItem('tcolor', color);
                }
                username = 'troll:'+uid;
                
                $("#userid").val(username);
                bindInfo(username,null)*/
                let trollTokenls = window.localStorage.getItem( 'troll' );
                if ( !trollTokenls ) {
                
                    const result = await $.ajax({
                        url: "https://api.bitwave.tv/api/troll-token",
                        type: 'GET'
                    });
                    //const { data } = await $.$axios.get('https://api.bitwave.tv/api/troll-token');
                    console.log('trollidinfo:',result);
                    trollTokenls = result.chatToken;
                    localStorage.setItem( 'troll', trollTokenls );
                    // just get the thing via jwt for the troll id
                    trolltoken = trollTokenls; // set our global, then we will let the firebase decide on the token to use
                    
                }
                trolltoken = trollTokenls;
                console.log("our troll token is:", trolltoken);
                // probably do this later... during the connection
                
                //return;
            }catch(err){
                // caught storage error most likely
                /*let uid   = [...Array(4)].map(() => (~~(Math.random()*36)).toString(36)).join('');
                let color = `hsl( ${Math.round(256 * Math.random())},75%,50%,1)`;
                username = 'troll:'+uid;
                
                $("#userid").val(username);
                userProfile.username = username;
                userProfile.color = color;
                userProfile.avatar = null;
                //restartConnection(userProfile);
                bindInfo(username,userProfile.avatar)*/
                console.log(err);
                
            }
        
            
        }


        //if(!forceTrollMode){
            try {
                if(window.localStorage.chatToken){
                    usertoken = window.localStorage.getItem('chatToken');
                    return;
                }
            
            
                /*if(window.localStorage.username){
                    userProfile.username = window.localStorage.getItem('username');
                    if(userProfile.username.length > 60){
                        userProfile.username = userProfile.username.substr(0,60);
                    }
                    userProfile.avatar = window.localStorage.getItem('avatar');
                    userProfile.userColor = window.localStorage.getItem('userColor');
                    userProfile.color = window.localStorage.getItem('color');
                    username = userProfile.username;
                    console.log("loaded info from storage:", username);
                    $("#userid").val(username);
                    
                    nh = gitfuggedniggerRot13(username + userProfile.avatar);
                    if(nh != lh){
                        userProfile.username = "troll:niggerShouldLogin";
                        username = userProfile.username;
                        userProfile.avatar = null;
                    }
                    
                    
                    return;
                }*/
            }
            catch(err){
                console.log('Error:',err.message);
            
            }
            
            forceTrollMode = true;
        //}
        
}



async function rngTrollSend(message_to_send){
    console.log("init new troll for chattting");
    disconnectChat();
    const result = await $.ajax({
        url: "https://api.bitwave.tv/api/troll-token",
        type: 'GET'
    });
    //const { data } = await $.$axios.get('https://api.bitwave.tv/api/troll-token');
    console.log('trollidinfo:',result);
    trollTokenls = result.chatToken;
    console.log(parseToken(trollTokenls).user.name);
    // destroy the connection to chat and make a new one
    $("#trollin").text(parseToken(trollTokenls).user.name);
    
    if(socket){
        socket.off('connect');
        socket.off('bulkmessage');
        socket.off('alert');
        socket.off('update usernames');
        socket.off('blocked');
        socket.off('pollstate');
        
        socket.disconnect();
        //socket.destory();
        socket = null;
        console.log(socket)
        console.log("Should have disconnected the socket")
    }
    
    socket = io( 'wss://chat.bitwave.tv', { transports: ['websocket'] } );
        const tempchannel = $( "#channelselect option:selected" ).text();
        
        
    socket.on('connect', () => {
           
            
            //recaptcha = null
            var userTokenObj = {
                    type  : 'user',
                    token:trollTokenls,
                    page: tempchannel
            }
            socket.emit('new user', userTokenObj);
            // show a connected message
            if(default_message.length > 0){
                message_to_send = default_message;
            }
            //$("#connectmepleasedeargod").toggleClass("hide");
            console.log("Connecting to chat... as a new troll id");
            // add message
            var global = '&trade;';
            if($("#filterchatbychannel").prop( "checked" )){
                global = false;// + global;
            }else{
                global = true;// + global;
            }
                const msg = {
                message: message_to_send,
                channel: channel,
                global: false
                
            };
            socket.emit('message',msg)
        });
        
        socket.on( 'bulkmessage', async data => await this.rcvMessageBulk(data) );
        
        socket.on( 'alert', async data => await this.addAlert(data) );

        socket.on( 'update usernames', async data => await this.updateUserWatchInfo(data) );

        socket.on( 'blocked',   data => messageBlocked(data)  ); // shoves the message back into the send buffer
        socket.on( 'pollstate', data => updatePoll(data) );
}

async function forceTrollNew(){
    // reconnect as a new troll id and start chatting...
    console.log("init new troll for chattting");
    disconnectChat();
    const result = await $.ajax({
        url: "https://api.bitwave.tv/api/troll-token",
        type: 'GET'
    });
    //const { data } = await $.$axios.get('https://api.bitwave.tv/api/troll-token');
    console.log('trollidinfo:',result);
    trollTokenls = result.chatToken;
    console.log(parseToken(trollTokenls).user.name);
    // destroy the connection to chat and make a new one
    $("#trollin").text(parseToken(trollTokenls).user.name);
    
    if(socket){
        socket.off('connect');
        socket.off('bulkmessage');
        socket.off('alert');
        socket.off('update usernames');
        socket.off('blocked');
        socket.off('pollstate');
        
        socket.disconnect();
        //socket.destory();
        socket = null;
        console.log(socket)
        console.log("Should have disconnected the socket")
    }
    
    socket = io( 'wss://chat.bitwave.tv', { transports: ['websocket'] } );
        const tempchannel = $( "#channelselect option:selected" ).text();
        
        
    socket.on('connect', () => {
           
            
            //recaptcha = null
            var userTokenObj = {
                    type  : 'user',
                    token:trollTokenls,
                    page: tempchannel
            }
            socket.emit('new user', userTokenObj);
            // show a connected message
            //$("#connectmepleasedeargod").toggleClass("hide");
            console.log("Connecting to chat... as a new troll id");
            // add message
        });
        
        socket.on( 'bulkmessage', async data => await this.rcvMessageBulk(data) );
        
        socket.on( 'alert', async data => await this.addAlert(data) );

        socket.on( 'update usernames', async data => await this.updateUserWatchInfo(data) );

        socket.on( 'blocked',   data => messageBlocked(data)  ); // shoves the message back into the send buffer
        socket.on( 'pollstate', data => updatePoll(data) );
    
}

function reconnectFC(){
    if(socket){
    
    }else{
    socket = io( 'wss://chat.bitwave.tv', { transports: ['websocket'] } );
        const tempchannel = $( "#channelselect option:selected" ).text();
        
        
    socket.on('connect', () => {
           
            
            
            activeUserProfile.page = tempchannel;
            socket.emit('new user', activeUserProfile);
            //socket.emit('new user', userTokenObj);
            // show a connected message
            //$("#connectmepleasedeargod").toggleClass("hide");
            console.log("Connecting to chat... as a new troll id");
            // add message
        });
        
        socket.on( 'bulkmessage', async data => await this.rcvMessageBulk(data) );
        
        socket.on( 'alert', async data => await this.addAlert(data) );

        socket.on( 'update usernames', async data => await this.updateUserWatchInfo(data) );

        socket.on( 'blocked',   data => messageBlocked(data)  ); // shoves the message back into the send buffer
        socket.on( 'pollstate', data => updatePoll(data) );
    }
}

function disconnectFC(){
    if(socket){
        socket.off('connect');
        socket.off('bulkmessage');
        socket.off('alert');
        socket.off('update usernames');
        socket.off('blocked');
        socket.off('pollstate');
        
        socket.disconnect();
        //socket.destory();
        socket = null;
        console.log(socket)
        console.log("Should have disconnected the socket")
    }
}



function messageBlocked(data){
    $("textarea#message").val(data.message);
    console.log("Should force you to reconnect to chat... before check");
    if($("#reconnectonblock").prop( "checked" )){
        console.log("Should force you to reconnect to chat...");
        // force reconnect to the chat
        disconnectFC();
        // then setup the fatchat
        reconnectFC();
    }else{
        console.log("box not checked....");
    }
}

makeTrollID();
//restartConnection("...");



setStreamMode();

hydrateChat();
restartConnection();

var baseurl = 'https://bitwave.tv/'

var sendbuffer = [];
const sendbuffer_size_limit = 20;
var send_buffer_index = 0


var connected = false;

var gmessages = "";

var serverUrl="https://chat.bitwave.tv";
var connectionStatus = false;
var sendMessage;

var scrollChat = true;

var useTTS = false;

var chatFeatureNotify = true;
var chatFeatureAFK = false;

var allowTrollsToToggleTTS = true;

var do_scroll_based_on_height = true;

var botrollEnabled = true;

var bindCodeForChat = '';

var doBind = false;

var sent_whispers = [];



var rcv_whispers = [];
var rcv_direct_messages = [];

var unsubscribePoll = null;

var unsubscribeUser = null;

var channel_watchers = new Set();

var read_names = false;

// fetch https://www.youtube.com/channel/UCjSRur4g895VBQ1I5jDwBRg 

// https://www.minuteinbox.com/

// https://www.spoofbox.com/en/tool/trash-mobile

function load_sent(){

    
    try{
        var ignore_string =  window.localStorage.getItem('sendbuffer');
        

        // try to restore the object from the string
        sendbuffer  = JSON.parse(ignore_string);
    }catch(err){
        sendbuffer = [];
    }
}

function save_sent(){
    
    try{
        var ignore_list = Array.from(sendbuffer);
        var myJSON = JSON.stringify(ignore_list);
        window.localStorage.setItem('sendbuffer'  , myJSON  );
    }catch(err){
    
    }
}

load_sent();


window.onunload = function(){
  //myfun();
  //alert('Bye.');
    if ( unsubscribeUser ){
        unsubscribeUser();
    }
    if ( unsubscribePoll ){
        unsubscribePoll();
    }
    if ( socket ){
        //socket.disconnect();
    }
}

var pollData = {};
pollData= {
          channel: '',
          display: false,
          endsAt: 0,
          id: '',
          options: [
            { label:'', votes: 0 },
            { label:'', votes: 0 },
          ],
          owner: '',
          title: '',
          voters: 0,
        }


function pauseScroll(){
    if(scrollChat){
        togglepause();
    }


}

function resumeScroll(){
    if(!scrollChat){
        togglepause();
        scrollToBottom();
    }

}

function updateWhisperCount(){
    // update the text area with the current set of crap stored for dms...
    var dms_text = "";
    dms.forEach( el => {
        
        function unescapeHtml(unsafe) {
                return unsafe
                    .replace(/&amp;/g,  `&`)
                    .replace(/&lt;/g,   `<`)
                    .replace(/&gt;/g,   `>`)
                    .replace(/&quot;/g, `"`)
                    .replace(/&#39;/g,  `'`)
                }

                el.message = unescapeHtml( el.message ); // Fixes escaped characters
                el.message = el.message.replace(/<(?=[^>]*<)/g,"&lt;");
    el.message = el.message.replace(/((?:\<\>)\w?).*/g,"&lt;");
    el.message = el.message.replace(/<\/?[^>]*>/g, '');
        
        // Remove Links
        el.message = el.message.replace(/((https?:\/\/)|(www\.))[^\s]+/gi, '');
    //el.message = processPremiumEmotes(el.message);
        dms_text += el.username + ": " + el.message + "\n";
    });
    
    $("textarea#whispers").val(dms_text);
    //$("#whispers").val(dms_text); // added hook to show the easy click window for dmstextarea id="dms
    $('#whispers_count').text("Whispers:" + dms.length);
}

function updateAtCount(){
    // technically this is the dm's count
    // update the text area with the current set of crap stored for ats...
    var ats_text = "";
    ats.forEach( el => {
        //el.message = el.message.replace(/<(?=[^>]*<)/g,"&lt;");
    //el.message = el.message.replace(/((?:\<\>)\w?).*/g,"&lt;");
    //el.message = processPremiumEmotes(el.message);
    function unescapeHtml(unsafe) {
                return unsafe
                    .replace(/&amp;/g,  `&`)
                    .replace(/&lt;/g,   `<`)
                    .replace(/&gt;/g,   `>`)
                    .replace(/&quot;/g, `"`)
                    .replace(/&#39;/g,  `'`)
                }

                el.message = unescapeHtml( el.message ); // Fixes escaped characters
        el.message = el.message.replace(/<\/?[^>]*>/g, '');
        
        // Remove Links
        el.message = el.message.replace(/((https?:\/\/)|(www\.))[^\s]+/gi, '');
        ats_text += el.username + ": " + el.message + "\n";
    });
    
    $("textarea#dms").val(ats_text);
    $('#ats_count').text("@'s:" + ats.length);
}
function channelListDropSelectionChanged(){
    // get the new channel name that is selected when it changes
    const selected_channel = $( "#channelselect option:selected" ).text();
    changeChatChannel(selected_channel); // use this to then set the new channel name
}

function changeChatChannel(newchannel){
    // probably need to go through the channel list
    
    
    $('#channelselect > option').each(function() {
        //alert($(this).text() + ' ' + $(this).val());
        const channelname = $(this).val();
        
        var s = document.location.search;
        key = encodeURIComponent('channel'); value = encodeURIComponent(newchannel);
        var kvp = key+"="+value;
        var r = new RegExp("(&|\\?)"+key+"=[^\&]*");
        s = s.replace(r,"$1"+kvp);
        if(!RegExp.$1) {s += (s.length>0 ? '&' : '?') + kvp;};
        document.location.search = s;
        //s += '?channel=playlistbot9k';
        if( channelname.toLowerCase() == newchannel){
            $( "#channelselect option[value="+channelname+"]" ).attr('selected','selected') //.text(selected_channel);
            //console.log('should change to:', channelname);
            const selected_channel = $( "#channelselect option:selected" ).text();
            window.document.title = 'LiteChat: ' + selected_channel;
            
            if(socket){
                console.log('should change our page that we are watching...');
                // should try to update the 
                getRecaptchaToken('litechat');
                activeUserProfile.page = channelname;
                socket.emit('new user', activeUserProfile);
            }
            //console.log('is now set to:', selected_channel);
            //return;
            // need to look at doing a join as well
            // socket.join(selected_channel);
        }else{
            // need to unselect the rest of the options in the list....
            $(this).removeAttr("selected");
        }
        
    });
    

}

function voices () {
    var voiceSelect = document.querySelector('select');
    //return voicesListTTS.map( (voice, index) => { return { text: voice.name, value: index } } );
    console.log("loading voice list... info for speech crap...");
    $('#voiceselect').empty();
    speechSynthesis.getVoices().forEach(function(voice) {
        console.log(voice.name, voice.default ? voice.default :'');
        // build the options select list
        $('#voiceselect').append('<option value="' + voice.name + '">' + voice.name + '</option>');
    });
    load_tts_settings();
    console.log('somthing...');
}

if (speechSynthesis.onvoiceschanged !== undefined) {
  speechSynthesis.onvoiceschanged = voices;
}

//if ('speechSynthesis' in window) {
    /*vlist = speechSynthesis.getVoices();
    console.log("voice list:",vlist);
    for( voi in vlist){
        console.log('voice:',vlist[voi]);
    }*/
    
//}

function connectToChat(){
    // start with active profile
    socket.emit('new user', activeUserProfile);
    //connectmepleasedeargod
}

/*
function getRecaptchaToken(action){
    try {
        grecaptcha.ready(function() {
            grecaptcha.execute('6LcEX8QUAAAAADjiUPfbzkyn0KYAaEK263quzCGh', {action: action}).then(function(rtoken) {
            //recaptcha = rtoken; // set our recaptcha
            activeUserProfile.recaptcha = rtoken;
            console.log('Recaptoken:',recaptcha);
            //return recaptcha;
            });
        });
    } catch ( error ) {
        console.log('Recapcha error:', error);
        // try to return 
        //recaptcha = null;// failed to set the recaptcha
        //return recaptcha;
    }

}*/

function restartConnection(userProfile){
    // need to destroy the old socket and make a new one to clean up the mess
    //socket.disconnect()
    // do we need to make it null?
    //delete socket;
    // then we need to reset the connection
    //socket.on( 'connect', () => this.socket.emit('new user', userProfile) );
    
    
    
    if(socket){
        socket.disconnect();
        socket = null;
    }
    
        // this is the old bind reconnect, but leaves up the old profile
        socket = io( 'wss://chat.bitwave.tv', { transports: ['websocket'] } );
        const tempchannel = $( "#channelselect option:selected" ).text();
        // we need to do a check to see if we have a usertoken or not to do the connection
        if(usertoken){
            // construct a profile of data (which we should already have
            // save our token to use 
            // use the token to start the connection
            
            var userTokenObj = {
                    type  : 'user',
                    token:usertoken,
                    page: tempchannel
            }
            username = parseToken(usertoken).user.name;
            //socket.on( 'connect', () => this.socket.emit('new user', userTokenObj) );
            //socket.on( 'reconnect', () => this.socket.emit('new user', userTokenObj) );
            
            activeUserProfile = userTokenObj;
            whisperSocketServer.emit('hi',username)
            if(recaptchat){
                activeUserProfile.recaptcha = recaptchat;
            }
            //socket.emit('new user', userTokenObj);
            console.log("should have connected as:", username);
             $("#userid").val(username);
        
        }else{
            // old connection method
            
            if(trolltoken){
                const tokenTroll = {
                    type  : 'troll',
                    token : trolltoken,
                    page  : tempchannel
                };
                //socket.on( 'connect', () => this.socket.emit('new user', tokenTroll) );
                //socket.on( 'reconnect', () => this.socket.emit('new user', tokenTroll) );
                //socket.emit('new user', tokenTroll);
                activeUserProfile = tokenTroll;
                //trolltoken
                if(recaptchat){
                    activeUserProfile.recaptcha = recaptchat;
                }
                // should then extract the troll id to use and show as the user...
                username = parseToken(trolltoken).user.name;
                whisperSocketServer.emit('hi',username)
                console.log("should have connected as:", username);
                $("#userid").val(username);
            }
        }
        
        
        //socket.on( 'connect', this.connectToChat()); //() => this.socket.emit('new user', userProfile) );
        
        
        socket.on('connect', () => {
            //socket.open();
            // get the recaptcha token
            // = getRecaptchaToken( 'connect' );
            // need to do firebase style stuff...
            //activeUserProfile.recaptcha = 
            //getRecaptchaToken('litechat');
            /*grecaptcha.ready(function() {
                grecaptcha.execute('6LcEX8QUAAAAADjiUPfbzkyn0KYAaEK263quzCGh', {action: 'litechat'}).then(function(rtoken) {
                activeUserProfile.recaptcha = rtoken; // set our recaptcha
                //activeUserProfile.recaptcha = rtoken;
                console.log('Recaptoken:',rtoken);
                //return recaptcha;
                });
            });*/
            //getRecaptchaToken('litechat');
            
            
            socket.emit('new user', activeUserProfile);
            // show a connected message
            $("#connectmepleasedeargod").toggleClass("hide");
            console.log("Connecting to chat...");
            // add message
        });
        
        //socket.on( 'hydrate', async data => await this.hydrate(data) );
        // this.socket.on( 'message', async data => await this.rcvMessage(data) );
        socket.on( 'bulkmessage', async data => await this.rcvMessageBulk(data) );
        
        socket.on( 'alert', async data => await this.addAlert(data) );

        socket.on( 'update usernames', async data => await this.updateUserWatchInfo(data) );

        socket.on( 'blocked',   data =>  messageBlocked(data)  ); // shoves the message back into the send buffer
        socket.on( 'pollstate', data => updatePoll(data) );
        
        
        // trying to debug the chat issue, just get rid of the disconnect handler, since the other one does not seem to get disconnected
        /*socket.on('disconnect', () => {
            //socket.open();
            console.log("should reconnect...");
            //socket.emit('new user', activeUserProfile);
            // show a connect button?
            // show chat disconnected...
            
            $("#connectmepleasedeargod").toggleClass("hide");
            // add message
            
            // force a reconnect, and hydrate the chat again because dispatch is a well you know...
            if(socket.disconnected){
                //socket.open();
                //restartConnection();
            }
            
        });*/
        
    /*}else{
        console.log("there isn't a socket...");
    
    }*/
    
    //socket = null
    //socket = io( 'wss://chat.bitwave.tv', { transports: ['websocket'] } ); //socket
    //socket.on( 'connect', () => this.socket.emit('new user', userProfile) );
    //this.socket.on( 'update usernames', async data => await this.updateViewerlist(data) );

    //socket.on( 'hydrate', async data => await this.hydrate(data) );
    // this.socket.on( 'message', async data => await this.rcvMessage(data) );
    //socket.on( 'bulkmessage', async data => await this.rcvMessageBulk(data) );
    /*var socket = io( 'wss://chat.bitwave.tv', { transports: ['websocket'] } ); //socket
    socket.on( 'connect', () => this.socket.emit('new user', userProfile) );
    //this.socket.on( 'update usernames', async data => await this.updateViewerlist(data) );

    socket.on( 'hydrate', async data => await this.hydrate(data) );
    // this.socket.on( 'message', async data => await this.rcvMessage(data) );
    socket.on( 'bulkmessage', async data => await this.rcvMessageBulk(data) );

    //this.socket.on( 'blocked',   data => this.message = data.message );
    //this.socket.on( 'pollstate', data => this.updatePoll(data) );

    whisperSocketServer = io('wss://bw.rnih.org:8088',{transports: ['websocket'] } ); //socket
    whisperSocketServer.on( 'connect', () => this.socket.emit('new user', userProfile) );
    //whisperSocketServer.on( 'hydrate', async data => await this.hydrate(data) ); // this will probably get any that we had waiting in the wing
    //whisperSocketServer.on( 'connected', async data => await this.wc(data) ); // this will probably get any that we had waiting in the wing
    whisperSocketServer.on( 'messagein', async data => await this.messagein(data) );
    whisperSocketServer.on( 'receipt_r', async data => await this.rr(data) );
    */
}

function messageFilterStateChange(){
    // save what ever the new check box state is for the filter preference
    if($("#filterchatbychannel").prop( "checked" )){
        try{
            window.localStorage.setItem('filterchatbychannel'  , true  );// user id
            
        }catch(ex){
        
        }
    }else{
        try{
            window.localStorage.setItem('filterchatbychannel'  , false  );// user id
        }catch(ex){
        
        }
    }
}

function trollFilterStateChange(){
    if($("#filterchattrolls").prop( "checked" )){
        try{
            window.localStorage.setItem('filterchattrolls'  , true  );// user id
        }catch(ex){
        
        }
    }else{
        try{
            window.localStorage.setItem('filterchattrolls'  , false  );// user id
        }catch(ex){
        
        }
    }
}


function toggletrollmode(){
    console.log("toggles troll mode state to log the user in and out");
    forceTrollMode = !forceTrollMode;
    if(forceTrollMode){
        $("#toggleTrollMode").val("Turn Off Troll Mode");
    }else{
        $("#toggleTrollMode").val("Turn On Troll Mode");
    }
    // look at renaming the connection token for the user 
    
    makeTrollID();
    //username='MarkCumner';
    //userProfile.username = username;
    restartConnection();
    /*if(username == ""){
        username = "troll";
    }*/
    console.log("you are now:",username);
}

function bindInfo(usernamem,avatarm){
    username = usernamem;
    doBind = false;
    // we should be able to set that we are logged out 
    $("#userid").val(username);
    // should store the id and use it or force a reconnect to chat
    try{
        window.localStorage.setItem('username'  , username  );// user id
        //window.localStorage.setItem('avatar'  , avatarm  );// avatar
        //window.localStorage.setItem('userColor'  , colorm  );// color
        //window.localStorage.setItem('color'  , colorm  );// color
    }catch(err){
        console.log("Failed to save the binding profile.");
    }
    
    //userProfile.username = username;
    //userProfile.avatar = avatarm;
    //userProfile.userColor = colorm;
    //userProfile.color = colorm;
    //nh = gitfuggedniggerRot13(username + avatarm )
    //console.log(nh);
    //console.log(lh);
    /*if(lh === nh){
        if( lh != null){
            restartConnection(userProfile);
        }
    }else{
        socket.disconnect();
    }*/
    restartConnection();
}

function bindToNewProfileName(message){
    if(doBind){
        // checks the message for the bind code so we can then bind to that user name and info and store it into the session for future connections
        var stuff_to_search = message.message;
        // Remove Links
        stuff_to_search = stuff_to_search.replace(/((https?:\/\/)|(www\.))[^\s]+/gi, '');

        // Remove html tags
        stuff_to_search = stuff_to_search.replace(/<\/?[^>]*>/g, '');
        // need to do regex clean up of messages to get rid of the paragraph elements
        console.log("looking for bind of:",bindCodeForChat, ' in: ', stuff_to_search, ' message user: ', message.username);
        if(stuff_to_search.trim() == bindCodeForChat.trim()){
            const usernamem = message.username;
            console.log("found a matching code!")
            /*lh = gitfuggedniggerRot13(usernamem + message.avatar );
            try{
                window.localStorage.setItem('lh'  , lh  );
            }catch(err){
                    console.log(err);
                }
            */
            bindInfo(usernamem,message.avatar);//,message.color);
        }
    }

}



function genBindCode(){
    // generates and sets the new bind code for chat, turns on the bind watch
    doBind = true;
    bindCodeForChat = Math.random().toString(36).replace('0.', '');
    $("#chatBinder").toggleClass("hide");
    // set it in the box
    // should show the box class="hide"
    $("#chatBinder").val(bindCodeForChat);
    $("#chatBinder").select();
    document.execCommand("copy");
    // hide the box
    $("#chatBinder").toggleClass("hide");
    
}

function openNewTabForVideo(){
    // should have to a new tab of the video player that has hls supported player and stream info for that page
    console.log('should open channel video')
}

function getChannelInfo(){
    console.log("updating the channel list...")
    // update the channel list
    //https://github.com/bitwave-tv/bitwave/blob/dev/components/SubLayout/sidebar/StreamerList.vue
    const apichannels="https://api.bitwave.tv/api/channels/live"
    $.get(apichannels, function(data, status){
        //alert("Data: " + data + "\nStatus: " + status);
        //console.log(data);
        //console.log(JSON.stringify(data, null, 4))
        const channelinfo_str = JSON.stringify(data, null, 4)
        const channel_info_obj =  JSON.parse(channelinfo_str)
        console.log("after data printed");
        //const channels = data;//JSON.parse(data);
        // get selection
        const selected_channel = $( "#channelselect option:selected" ).text();
        $('#channelselect').empty();// clear the list and add the new options back in
        $('#channelselectoffline').empty(); // this will be used for the video player, for times of trouble
        $('#channelselectoffline').hide();
        for( channel in channel_info_obj.users){
            //console.log(channel[channel].name);
            //console.log(channel[channel].title);
            //console.log(channel[channel].url);
            const chname = channel_info_obj.users[channel].name;
            const churl = channel_info_obj.users[channel].url;
            const chlive = channel_info_obj.users[channel].live;
            //console.log(chname);
            //console.log(churl);
            
            if(chlive ){
                //$('#channelselect').append('<option value="' + chname + '">' + chname + '</option>');
                channels.add(chname);
            }else{
                
                $('#channelselectoffline').append('<option value="' + chname + '">' + chname + '</option>');
            }
        }
        
        // then we can go through the channel list and build the channel set again
        for (var it = channels.values(), val= null; val=it.next().value; ) {
            $('#channelselect').append('<option value="' + val + '">' + val + '</option>');
        }
        
        // should check if it exists before we change the selection
        if($("#channelselect option[value='selected_channel']").length > 0){
            $('#channelselect').append('<option value="' + selected_channel + '">' + selected_channel + '</option>');
        }else{
            
        }
        
        //$('#channelselect').append('<option value="' + selected_channel + '">' + selected_channel + '</option>');
        // restore the selection
        $( "#channelselect option[value="+selected_channel+"]" ).attr('selected','selected') //.text(selected_channel);
    });
}

getChannelInfo();


function saveAutoScrollSetting(){

    //forceScrollToBottom = !forceScrollToBottom;
    if(forceScrollToBottom == 'true' || forceScrollToBottom == true){
        forceScrollToBottom = false;
    }else{
        //if(forceScrollToBottom == 'false' || forceScrollToBottom == false){
            forceScrollToBottom = true;
        //}
    }
    
    console.log('ForcedScrollState:' + forceScrollToBottom);

    try {
            //forceScrollToBottom   = window.localStorage.getItem('forceScrollToBottom');
            //let color = window.localStorage.getItem('tcolor');
            
            window.localStorage.setItem('forceScrollToBottom'  , forceScrollToBottom  );
            
        }catch(err){
            // caught storage error most likely
            //forceScrollToBottom = false;
            //restartConnection(userProfile);
        }
        
    setScrollPauseForceState();

}

function setScrollPauseForceState(){
    if(forceScrollToBottom){
        $("#pausechat").val("Hover Pause On");
    }else{
        $("#pausechat").val("Hover Pause Off");
    }

}


function togglepause(){
    scrollChat = !scrollChat;
    console.log("new scroll state:", scrollChat)
    
    /*if(scrollChat){
        $("#pausechat").val("Pause Chat Scroll");
    }else{
        $("#pausechat").val("Resume Chat Auto Scroll");
    }*/

}

function toggletts(){
 useTTS = !useTTS;
 
    if(useTTS){
        
        $("#toggleTTS").val("Turn Off TTS");
    }else{
        $("#toggleTTS").val("Turn On TTS");
    }
 
}


function getImageAlt(){
    // returns the alt of the image tag

}

function togglenotify(){
    chatFeatureNotify = !chatFeatureNotify;
    
    if(chatFeatureNotify){
        $("#toggleNotify").val("Turn Off Notify");
    }else{
        $("#toggleNotify").val("Turn On Notify");
    }

}

function toggleAFK(){
    chatFeatureAFK = !chatFeatureAFK;
    
    if(chatFeatureAFK){
        $("#toggleAFK").val("Turn Off AFK");
    }else{
        $("#toggleAFK").val("Turn On AFK");
        
    }

}
// "userColor":"#FF69B4"
/*

https://github.com/CleverRaven/Cataclysm-DDA

avatar: null
channel: "dispatchmobile"
color: "hsl( 9,75%,50%,1)"
message: "<p>IF YOU NEED A FLOP CALL DISPATCH IF YOU NEED A REAL FLIP CALL MANDA....</p>â†µ"
clay drinks https://streamable.com/kbwyl
timestamp: 1560222321326
username: "troll:0rn6"*/

function append_sent(last_message){
    last_message = last_message.trim()
    try{
    
        sendbuffer.unshift(last_message); // needs to be push front 
    
    
    
    // clean up the value with pop
    if( sendbuffer.length > sendbuffer_size_limit + 20){
        while(sendbuffer.length > sendbuffer_size_limit){
            sendbuffer.pop()
        }
    }
    }catch(err){
    
    }
    
    sendbuffer = removeDups(sendbuffer);
    send_buffer_index = 0;
    save_sent();
}

function sendPremium(){
    const premiumMessage = ' - This message was sent by Bitwave Premium&trade;';
    const messageText = $("textarea#message").val();
    if(messageText.trim().length > 0){
        $("textarea#message").val(messageText + premiumMessage);
    }else{
        $("textarea#message").val(messageText + "Who is John Gault :shrug: " + premiumMessage);
    }
    send();
}

function sendWhisperLC(messageText){
    const withChannelSub = messageText.replace(/@@/gi, '@'+tempchannel);
    
        const withChannelSubNoReturns = withChannelSub.replace(/\n|\r/g, "");
        console.log('whisper test');
        //const message_to_split = $("textarea#message").val();
        var parts = withChannelSubNoReturns.split(" ");
        // 0 is !w, 1 is username, after that point the rest is the actual message
        
        var tuser = 'troll:y1e0';
        if(parts.length > 1){
            tuser = parts[1];
        }
        var start_len = 0;
        start_len += tuser.length + 1
        const rest_of_message = messageText.substr(start_len,messageText.length).trim();
        const msg_id = Math.random().toString(36).replace('0.', '');
        const msg = {
            message: "<p>" + rest_of_message + "</p>",
            channel: channel,
            to: 'playlistbot',
            from: username,
            msg_id: msg_id
          };
        if(whisperSocketServer){
            // this does send but we get that damn print prompt
            whisperSocketServer.emit('messagew', msg);//whisper
            $("textarea#message").val("");
        }
}

function sendWhisper(receiver,message){
    // need to hook up or use the litechat whisper instead...
    
    //return;

    const endpoint = 'https://api.bitwave.tv/v1/whispers/send';
    //console.log('user token', usertoken)
    const payload = {
      chatToken: activeUserProfile.token,
      receiver: receiver,
      message: message,
    };
    //const { data } = await this.$axios.post( endpoint, payload, { progress: false, skipAuth: true } );
    try{
    /*var xhr = new XMLhttpsRequest();
    xhr.open("POST", endpoint,true);
    xhr.setRequestHeader("Content-type", "application/json;charset=UTF-8");
    xhr.send(JSON.stringify(payload)); */
    
    $.post( endpoint, payload, function(data, status){
                console.log(status);
                if(status == "success"){
                        
                        
                }
            });
    
    //var {data} = await 
    /*$.ajax({
            url: endpoint,
            type: 'POST',
            data: JSON.stringify(payload),
            contentType: "application/json",
            dataType: 'json'
        });*/
      //  console.log("whisper result:", data)
        $("textarea#message").val();
    }catch(ex){
        console.log(ex)
    }
}

function addtoplaylist(){
    const itemText = $("#playlistitem").val();
    const tempchannel = $( "#channelselect option:selected" ).text();
    // need to enforce the length and not send if it isn't the right size
    // should show/fade a error message, or change the button color to red or something
    // fuck dispatch over and over
    // message: "!w playlistbot addtoplaylist " + itemText,
    
          //sendWhisperLC("playlistbot",'atp ' + btoa(itemText)) 
          
    if(socket){
        if(itemText.trim().length > 0){
            if(!litechat){
             /*const msg = {
                message: "@playlistbot atp " + itemText,
                channel: tempchannel,
            };*/
            //socket.emit('message', msg);
            const msg = {
                    message: "@playlistbot atp " + btoa(itemText),
                    channel: tempchannel,
                    user:username
                };
                whisperSocketServer.emit('say',msg);
                $("#playlistitem").val("");
            }else{
                const msg = {
                    message: "@playlistbot atp " + btoa(itemText),
                    channel: tempchannel,
                    user:username
                };
                whisperSocketServer.emit('say',msg);
                $("#playlistitem").val("");
            }
            //$("#playlistitem").val("");
            //whisperSocketServer.emit('say',msg);
            
            //sendWhisper("playlistbot",'atp ' + btoa(itemText)) 
            $("#playlistitem").val("");
        }
    }else{
        const msg = {
            message: "@playlistbot atp " + btoa(itemText),
            channel: tempchannel,
            user:username
          };
        whisperSocketServer.emit('say',msg);
        $("#playlistitem").val("");
    }

}

function startPL(){
    //const itemText = $("#playlistitem").val();
    const tempchannel = $( "#channelselect option:selected" ).text();
    // need to enforce the length and not send if it isn't the right size
    // should show/fade a error message, or change the button color to red or something
    // fuck dispatch over and over message: "!w playlistbot startplaylist",
    // jdanks https://hatebin.com/qeqcfrroyj
    // cellphone rotary https://skysedge.us/unsmartphones/index.html
    const msg = {
            message: "@playlistbot startplaylist",
            channel: tempchannel,
            user:username
          };
          whisperSocketServer.emit('say', msg);
    if(socket){
        //
        
        //sendWhisper("playlistbot",'startplaylist') 
    }

}

function escapeHtml(text){
    return text.replace(/[&<>"'\/]/g, function (s) {
      var entityMap = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': '&quot;',
          "'": '&#39;',
          "/": '&#x2F;'
        };

      return entityMap[s];
    });
  }


function tryReconnect(){
    if(socket.disconnected){
        disconnectChat();
    }
}
  
  
function unsetaudiobinds(){
    localStorage.removeItem( 'useQuad');
    localStorage.removeItem( 'useRail');
    localStorage.removeItem( 'useMenu');
    localStorage.removeItem( 'useHit');
    localStorage.removeItem( 'useProtect');
    localStorage.removeItem('useRunty');
    $("textarea#message").val("");
}

function forceDisconnectOfFatChat(){
    // used to check the status of if we want to disconnect fatchat or just never connect to it by default
    if(socket){
        socket.off('connect');
        socket.off('bulkmessage');
        socket.off('alert');
        socket.off('update usernames');
        socket.off('blocked');
        socket.off('pollstate');
        
        socket.disconnect();
        //socket.destory();
        socket = null;
    }
}

function checkChatConnections(){
    // used to set the status indicators for litechat and fatchat
    if(socket){
        if(socket.disconnected){
            // set that fat chat is disconnected with a red indicator 
            // change the color of something somewhere, maybe the lc and on channel text by adding a color class to change the color of the text
            //div id="watchcount" class="labelhelper" 
            $("#watchcount").addClass("disconnected");
        }else{
            $("#watchcount").removeClass("disconnected");
        }
    }else{
        $("#watchcount").addClass("disconnected");
    }
    
    if(whisperSocketServer.disconnected){
        // set that litechat is not connected
        //div id="lc_count" class="labelhelper"
        $("#lc_count").addClass("disconnected");
    }else{
        $("#lc_count").removeClass("disconnected");
    }
}

function hop(){
    qtrollchange();
    socket.emit('message',{message:$("textarea#message").val(),channel:$("textarea#darkChannel").val()});
}
  
function send(){
    
    
    //if(socket.disconnected){
        //disconnectChat();
    //}
    
    var messageText = $("textarea#message").val();
    //console.log("messageToSend:\n"+messageText.substr(0,4)+"ENDOFMESSAGE");
    const tempchannel = $( "#channelselect option:selected" ).text();
    //console.log("chatting with channel:", tempchannel);
    channel = tempchannel;
    
    if(messageText.substr(0,3) == "!ww" || messageText.substr(0,2) == "!WW" || messageText.substr(0,3) == "/ww" || messageText.substr(0,2) == "/WW"){
        const withChannelSub = messageText.replace(/@@/gi, '@'+tempchannel);
    
        const withChannelSubNoReturns = withChannelSub.replace(/\n|\r/g, "");
        console.log('whisper test');
        //const message_to_split = $("textarea#message").val();
        var parts = withChannelSubNoReturns.split(" ");
        // 0 is !w, 1 is username, after that point the rest is the actual message
        
        var tuser = 'troll:y1e0';
        if(parts.length > 1){
            tuser = parts[1];
        }
        var start_len = 3;
        start_len += tuser.length + 1
        const rest_of_message = messageText.substr(start_len,messageText.length).trim();
        const msg_id = Math.random().toString(36).replace('0.', '');
        const msg = {
            message: "<p>" + rest_of_message + "</p>",
            channel: channel,
            to: tuser,
            from: username,
            msg_id: msg_id
          };
          
        sent_whispers.push(msg);
        
        const msg_to_add_locally = {
            message: "<p>To: " + tuser + " " + rest_of_message + "</p>",
            username: username,
            channel: 'Whisper'
        
        }
        //ats
        //dms.push(msg_to_add_locally);
        addMessage(msg_to_add_locally);
        
        if(whisperSocketServer){
            // this does send but we get that damn print prompt
            whisperSocketServer.emit('messagew', msg);//whisper
            $("textarea#message").val("");
        }
        return;
    }
    
    if(messageText.substr(0,2) == "!@" ){
        messageText = messageText.replace(/!@/gi, '!w '+tempchannel);
        /*const msg = {
            message: messageText,
            channel: tempchannel,
        };*/
        //socket.emit( 'whisper', msg );
        //append_sent(messageText);
        //return;
    }
    
    if(messageText.substr(0,3) == "/W " || messageText.substr(0,3) == "/w " || messageText.substr(0,3) == "!w " || messageText.substr(0,3) == "!W "){
        const msg = {
            message: messageText,
            channel: tempchannel,
        };
        //socket.emit( 'whisper', msg );
        // get the user out of the message which is part 2
        // then the rest of the message as a sub string... also need to patch the bot to allow it to send whispers via the api
        var chunks = messageText.split(" ")
        var toUser = chunks[1]
        var restOfMessage = ""
        
        for(var i =2;i<chunks.length;i++){
            restOfMessage += chunks[i] + " "
        }
        //console.log("Should send whisper to: ", toUser)
        
        //console.log("rest of the message that we want to send:", restOfMessage)
        // message: "<p>To: " + tuser + " " + rest_of_message + "</p>",
        sendWhisper(toUser,restOfMessage)
        const msg_to_add_locally = {
            message: "<p>To: " + toUser + " " + restOfMessage + "</p>",
            username: "Me",
            channel: 'Whisper'
        
        }
        //ats
        //dms.push(msg_to_add_locally);
        addMessage(msg_to_add_locally);
        
        
        
        append_sent(messageText);
        $("textarea#message").val("");
        return
    }
    
    
    if(messageText.substr(0,4) == "/tos"){
        const msg = {
            message: "Please read the [Terms of Service](https://bit.ly/2vkq4Mz)",
            channel: channel
          };
        if(socket){
            socket.emit('message', msg);
            $("textarea#message").val("");
        }
        append_sent(messageText);
        return;
    }
    
    //rngTrollSend()
    if(messageText.substr(0,9) == "/rngtroll"){
        /*const msg = {
            message: "Please read the [Terms of Service](https://bit.ly/2vkq4Mz)",
            channel: channel
          };*/
        /*if(socket){
            socket.emit('message', msg);
            $("textarea#message").val("");
        }*/
        var start_len = 9;
        const rest_of_message = messageText.substr(start_len,messageText.length).trim();
        rngTrollSend(rest_of_message);
        $("textarea#message").val("");
        append_sent(messageText);
        return;
    }
    
    if(messageText.substr(0,7) == "/notify"){
        togglenotify();
         $("textarea#message").val("");
        return;
    }
    
    
    //autocompleter
    if(messageText.substr(0,5) == "/auto"){
        // toggles autocomplete on and off
        autocompleter();
        $("textarea#message").val("");
        return;
    }
    
    if(messageText.substr(0,5) == "/dcfc"){
        // toggles autocomplete on and off
        // disconnects from fat chat
        //autocompleter();
        forceDisconnectOfFatChat();
        $("textarea#message").val("");
        return;
    }
    
    if(messageText.substr(0,5) == "/dclc"){
        // toggles autocomplete on and off
        // disconnects from fat chat
        //autocompleter();
        $("textarea#message").val("");
        return;
    }
    
    if(messageText.substr(0,9) == "/dispatch"){
        //togglenotify();
        var info = "";
        var spot_user = "dispatch";
        var chunks = messageText.split(" ")
        if( chunks.length > 1){
            spot_user = chunks[1].trim()
        }
        var found_in = ""
         $.get('https://chat.bitwave.tv/v1/channels', function(data, status){

            for( var ch in data.data){
                info += data.data[ch].channel + ": " + data.data[ch].viewCount + "<br>";
                for(var viewer in data.data[ch].viewers){
                    if(data.data[ch].viewers[viewer].toLowerCase().includes(spot_user.toLowerCase())){
                        found_in += data.data[ch].channel + "<br>";
                    }
                }
            }
            
            const msg_to_add_locally = {
                message: "<p>Found: <br>" + spot_user + " in: <br>" + found_in + " </p>",
                username: "Me",
                channel: 'Whisper'
        
            }
            //ats
            //dms.push(msg_to_add_locally);
            addMessage(msg_to_add_locally);
            // loops through the list and adds a local message with each channels view count
            
        })
            // finds dispatch in the viewer list and tells you which channels he is in, or could be used for any user technically
         $("textarea#message").val("");
        return;
    }
    
    if(messageText.substr(0,10) == "/chatstats"){
        // toggles autocomplete on and off
        //autocompleter();
        var info = "";
         $.get('https://chat.bitwave.tv/v1/channels', function(data, status){

            for( var ch in data.data){
                info += data.data[ch].channel + ": " + data.data[ch].viewCount + "<br>";
                
            }
            const msg_to_add_locally = {
                message: "<p>Channel info: <br>" + info + "</p>",
                username: "Me",
                channel: 'Whisper'
        
            }
            //ats
            //dms.push(msg_to_add_locally);
            addMessage(msg_to_add_locally);
            // loops through the list and adds a local message with each channels view count
            
        })
        // loop throught he channels and get the counts
        $("textarea#message").val("");
        
        return;
    }
    
    if(messageText.substr(0,9) == "/litechat"){
        // toggles the chat output to litechat only
        litechat = ! litechat;
        $("textarea#message").val("");
        return;
    }
    
    if(messageText.substr(0,7) == "/fatchat"){
        // goes to bitewave sockets
    
    }
    
    if(messageText.substr(0,7) == "/ignore"){
        //togglenotify();
        var start_len = 7;
        //start_len += tuser.length + 1
        const rest_of_message = messageText.substr(start_len,messageText.length).trim().toLowerCase();
        add_remove_to_ignore(rest_of_message);
        append_sent(messageText);
         $("textarea#message").val("");
        return;
    }
    
    if(messageText.substr(0,8) == "/tignore"){
        //togglenotify();
        
        do_ignore = false; // turns off global ignore which is on by default
        
         $("textarea#message").val("");
        return;
    }
    
    
    if(messageText.substr(0,3) == "/ic"){
        var start_len = 3;
        //start_len += tuser.length + 1
        const rest_of_message = messageText.substr(start_len,messageText.length).trim().toLowerCase();
        add_remove_to_ch_ignore(rest_of_message);
        append_sent(messageText);
         $("textarea#message").val("");
        return;
    
    }
    
    
    if(messageText.substr(0,11) == "/ignorewipe"){
        ignore_set = new Set();
        $("textarea#message").val("");
    }
    
    if(messageText.substr(0,4) == "/afk"){
        toggleAFK();
         $("textarea#message").val("");
        return;
    }
    
    if(messageText.substr(0,5) == '/quad'){
        unsetaudiobinds();
        localStorage.setItem( 'useQuad', "1" );
        return;
    }
    
    if(messageText.substr(0,6) == '/bones'){
        unsetaudiobinds();
        localStorage.setItem( 'useBones', "1" );
        return;
    }
    
    if(messageText.substr(0,6) == '/menu1'){
        unsetaudiobinds();
        localStorage.setItem( 'useMenu', "1" );
        return;
    }
    
    if(messageText.substr(0,6) == '/menu2'){
        unsetaudiobinds();
        localStorage.setItem( 'useMenu', "2" );
        return;
    }
    
    if(messageText.substr(0,6) == '/menu3'){
        unsetaudiobinds();
        localStorage.setItem( 'useMenu', "3" );
        return;
    }
    
    if(messageText.substr(0,6) == '/menu4'){
        unsetaudiobinds();
        localStorage.setItem( 'useMenu', "4" );
        return;
    }
    
    // adds support for rail railgf1a.wav
    if(messageText.substr(0,5) == '/rail'){
        unsetaudiobinds();
        //localStorage.setItem( 'useQuad', "0" );
        localStorage.setItem( 'useRail', "1" );
        return;
    }
    
    if(messageText.substr(0,8) == '/gaysnow'){
        $("textarea#message").val("");
        $('#messageListContainer').toggleClass("snow-bg");
        return;
    }
    
    if(messageText.substr(0,8) == '/hydrate'){
        $("textarea#message").val("");
        //$('#messageListContainer').toggleClass("snow-bg");
        hydrateChat();
        // force the manual update to hydrate chat from https
        return;
    }
    
    if(messageText.substr(0,6) == '/clear'){
        //unsetaudiobinds();
        $("textarea#message").val("");
        clearMessages();
        //localStorage.setItem( 'useMenu', "4" );
        return;
    }
    
    if(messageText.substr(0,6) == '/local'){
        //unsetaudiobinds();
        $("textarea#message").val("");
        //clearMessages();
        //messageFilterStateChange();
        // https://github.com/bitwave-tv/bitwave/blob/dev/assets/js/effects/Fireworks.js
        // https://github.com/bitwave-tv/bitwave/commit/456c323cf3d90f7f8f2682e507e45c4ddefac3c3
        // https://github.com/bitwave-tv/bitwave/tree/dev/assets/style
        // https://github.com/bitwave-tv/bitwave/blob/dev/assets/style/chat-extras.scss
        $("#filterchatbychannel").prop("checked", !$("#filterchatbychannel").prop("checked"));
        //localStorage.setItem( 'useMenu', "4" );
        return;
    }
    
    if(messageText.substr(0,4) == '/hit'){
        unsetaudiobinds();
        
        localStorage.setItem( 'useHit', "1" );
        //localStorage.setItem( 'useRail', "1" );
        return;
    }
    
    if(messageText.substr(0,'/updateemotes'.length) == '/updateemotes' || messageText.substr(0,'/ue'.length) == '/ue'){
        // forces the update of emotes
        $("textarea#message").val("");
        console.log("Fetching new emotes...");
        checkForNewPremiumEmotes();
        console.log("Done Fetching new emotes...");
        return;
    }
    
    if(messageText.substr(0,8) == '/protect'){
        unsetaudiobinds();
        
        localStorage.setItem( 'useProtect', "1" );
        //localStorage.setItem( 'useRail', "1" );
        return;
    }
    
    if(messageText.substr(0,6) == '/runty'){
        unsetaudiobinds();
        localStorage.setItem('useRunty','1');
        return;
    
    }
    
    
    
    if(messageText.substr(0,8) == '/default'){
        unsetaudiobinds();
        return;
    }
    if(messageText.substr(0,4) == "/sir"){
        const msg = {
            message: 'SIÂ­R',
            channel: channel
          };
        if(socket){
            socket.emit('message', msg);
            $("textarea#message").val("");
        }
        return;
    }
    
    if(messageText.substr(0,4) == '/say'){
        
        // say this to only litechat
        var message = messageText;
        var restofmessage = message.substring(message.search("/say ") + 5);
        const msg_id = Math.random().toString(36).replace('0.', '');
        /*to: tuser,
            from: username,
            msg_id: msg_id*/
        
        const msg = {
            message: restofmessage,
            channel: channel,
            user: username
          };
          whisperSocketServer.emit('say', msg);
          $("textarea#message").val("");
        return;
    }
    
    if(messageText.substr(0,7) == "/how2lc"){
        //toggleAFK();
        // go to advanced and push the button that says gen bind code and copy, then paste that into regular bitwave chat if you want to have your regular username - This message was sent by Bitwave Premiumâ„¢
        const how2message = 'You need to click advanced, then push the button that says `Gen Bind Code AND COPY`, then paste that into a bitwave chat you are logged into and send it.';
        const msg = {
            message: how2message,
            channel: channel
          };
        if(socket){
            socket.emit('message', msg);
            $("textarea#message").val("");
        }
         
        return;
    }
    // 
    
    if(messageText.substr(0,7) == "/linklc"){
        //toggleAFK();
        const how2message = 'https://bw.rnih.og/litechat/';
        const msg = {
            message: how2message,
            channel: channel
          };
        if(socket){
            socket.emit('message', msg);
            $("textarea#message").val("");
        }
         
        return;
    }
    
    
    if(messageText.substr(0,9) == "/rngkitty"){
        
        const msg = {
            message: "# :smhkitty:",
            channel: channel
          };
        if(socket){
            socket.emit('message', msg);
            $("textarea#message").val("");
        }
        $("textarea#message").val("");
        return;
    }
    
    if(messageText.substr(0,1) == "/"){
        // failed to match command and we'll let you know that you suck
        const msg_to_add_locally = {
                message: "<p>You failed to enter a command: <br>" + messageText + "</p><p>Please try correcting it and running it again, sometimes you get a second chance</p>",
                username: "Me",
                channel: 'Whisper'
        
            }
            //ats
            //dms.push(msg_to_add_locally);
            addMessage(msg_to_add_locally);
        return;
    }
    // do a replace of @@ with the channel
    const withChannelSub = messageText.replace(/@@/gi, '@'+tempchannel);
    
    const withChannelSubNoReturns = withChannelSub.replace(/\n|\r/g, "").trim();
    
        //console.log('' + withChannelSubNoReturns);
            
        if(socket){
            var message_to_send = withChannelSubNoReturns;
            //message_to_send = message_to_send.replace(/<[^>]*>?/gm, '');
            // try and do a rng emote sub if they are found
            message_to_send = subRngGaytor(message_to_send);
            message_to_send = subRngRareJan(message_to_send);
            
            
            if(message_to_send.length > 299){
                message_to_send = message_to_send.substr(0,300);
                console.log('new message length:', message_to_send.length);
            }
            
            // need to do some more clean up of the message before send to strip out html crap or escape it before send
            //https://www.youtube.com/channel/UCnXpLU21ufLJ0Sdgfj46MQw/live
            if(default_message.length > 0){
                message_to_send = default_message;
            }
            
            var global = '&trade;';
            if($("#filterchatbychannel").prop( "checked" )){
                global = false;// + global;
            }else{
                global = true;// + global;
            }
                const msg = {
                message: message_to_send,
                channel: channel,
                
            }; // global  : global,
            
            // should filter most of the numbers out of the list
            if(message_to_send.length > 4){
                append_sent(message_to_send);
            }
            
            // see if we have lc on or fat chat on and use it to send the messages
            if (litechat){
                const lcmsg = {
                    message: message_to_send,
                    channel: channel,
                    user: username
                };
                whisperSocketServer.emit('say', lcmsg);
            }else{
                socket.emit('message', msg);
            }
            
            
          
            
            $("textarea#message").val("")
            // should auto turn off afk 
            if(chatFeatureAFK){
                toggleAFK();
            }
        }else{
            console.log("not connected or defined");
            saylc(withChannelSubNoReturns);
            $("textarea#message").val("")
            // should send via lc if it's connected...
        }
};

function saylc(message){
    //var message = messageText;
        var restofmessage = message;//.substring(message.search("/say ") + 5);
        const msg_id = Math.random().toString(36).replace('0.', '');
        /*to: tuser,
            from: username,
            msg_id: msg_id*/
        
        const msg = {
            message: restofmessage,
            channel: channel,
            user: username
          };
          whisperSocketServer.emit('say', msg);
          $("textarea#message").val("");

}

function subRngGaytor(message){
    
    var rnggaytor = getRngEmote("gaytor",1,15);
    
    // then find and replace ":rnggaytor: with the new inner
    const replacer = ":" + rnggaytor + ":";//"<img src=\"" + eurl + "\" alt=\"" + alt + "\">";
            //premiumEmotes = premiumEmotes.replace('/:'+ alt +':/gi','<img src="' + eurl + '" alt="'+alt+'">');
    const findmetext = "rnggaytor";
    const pattern = new RegExp(`:${findmetext}:`, 'gi' );
    var new_msg = message.replace(pattern,replacer);
    //var new_msg = message.replace(/\n|\r/g, "");

    return new_msg;
}

function subRngRareJan(message){
    
    var rnggaytor = getRngEmote("rarejan",1,15);
    
    // then find and replace ":rnggaytor: with the new inner
    const replacer = ":" + rnggaytor + ":";//"<img src=\"" + eurl + "\" alt=\"" + alt + "\">";
            //premiumEmotes = premiumEmotes.replace('/:'+ alt +':/gi','<img src="' + eurl + '" alt="'+alt+'">');
    const findmetext = "rngrarejan";
    const pattern = new RegExp(`:${findmetext}:`, 'gi' );
    var new_msg = message.replace(pattern,replacer);
    //var new_msg = message.replace(/\n|\r/g, "");

    return new_msg;
}

function readTTSmessage(message){
    const voice = new SpeechSynthesisUtterance();
        const pitch = 1;
        //voice.voice = 0;//this.voicesListTTS[this.selectionTTS];
        //const selectedOption = $( "#voiceselect option:selected" ).text();
        // need to set the voice
        const selectedOption = vSelected;
        voices = speechSynthesis.getVoices();
        for(var i = 0; i < voices.length ; i++) {
            if(voices[i].name === selectedOption) {
            voice.voice = voices[i];
            }
        }
        
        voice.rate  = 10.0/10.0;//this.rateTTS / 10.0;
        voice.pitch = pitch;
        
        
        // Remove html tags
        message = message.replace(/<\/?[^>]*>/g, '');
        
        // Remove Links
        message = message.replace(/((https?:\/\/)|(www\.))[^\s]+/gi, '');
        // need to remove the ' character or sub it
        message = message.replace(/&#39;/g, '');
        
        
        voice.text  = message;

        voice.onend = function(e) {
          console.log(`Finished in ${e.elapsedTime} seconds.`, e);
        };

        speechSynthesis.speak(voice);

}






//whisperSocketServer.emit('hi',parseToken(activeUserProfile).user.name)
try{
//whisperSocketServer.on( 'connect', () => this.socket.emit('hi', parseToken(activeUserProfile).user.name) );
}catch(ex){
    console.log(ex)
}
//whisperSocketServer.on( 'hydrate', async data => await this.hydrate(data) ); // this will probably get any that we had waiting in the wing
//whisperSocketServer.on( 'connected', async data => await this.wc(data) ); // this will probably get any that we had waiting in the wing
whisperSocketServer.on( 'messagein', async data => await this.messagein(data) );
whisperSocketServer.on( 'receipt_r', async data => await this.rr(data) );
whisperSocketServer.on( 'said', async data => await this.said(data) );

// should look at the polls
function updatePoll (data) {
    console.log(data);
    console.log("updatePoll");
    pollData.options = data.options;
    pollData.voters = data.voters;
    console.log("poll data updated:", data.options, data.voters);
}

function votePoll (vote) {
    // should pass option number & poll id
    socket.emit('votepoll', { id: pollData.id, vote: vote })
}

 // Change end time to now to end poll instantly
      function endPoll (pollId) {
        // this.socket.emit('endpoll', pollId)

        const pollDocRef = db.collection('polls').doc(pollData.id);
        pollDocRef.update( 'endsAt', new Date(Date.now()) );
      }

      function destroyPoll (pollId) {
        const pollRef = db.collection('polls').doc(pollId);
        pollRef.update({ 'display': false, 'options': null });
      }

      function updatePoll (data) {
        pollData.options = data.options;
        pollData.voters = data.voters;
      }

function createPoll (poll) {
    if ( pollData.id ) {
          const pollDocRef = db.collection('polls').doc(pollData.id);
          const data = {
            display: true,
            endsAt: new Date( Date.now() + poll.time * 60 * 1000 ),
            options: poll.options,
            title: poll.title,
          };
          pollDocRef.update(data);
        } else {
          const data = {
            channel: this.page.toLowerCase(),
            display: true,
            endsAt: new Date( Date.now() + poll.time * 60 * 1000 ),
            options: poll.options,
            owner: this.user.uid,
            title: poll.title,
        };
        pollData.id = db.collection('polls').add(data);
    }
}

/*
firebase.auth().signInAnonymously().catch(function(error) {
  // Handle Errors here.
  var errorCode = error.code;
  var errorMessage = error.message;
  // ...
});*/

function subscribeToPoll (channel) {
        channel = channel.toLowerCase();
        const pollDocRef = db.collection('polls').where('channel', '==', channel).limit(1);
        unsubscribePoll = pollDocRef.onSnapshot( result => {
          if (result.empty) return;
            console.log("we found a poll...");
          const doc = result.docs[0];
            console.log(doc);
          pollData = doc.data();
          console.log(pollData);
          pollData.id = doc.id;
            console.log("poll id:",pollData.id);
            console.log("poll channel:",pollData.channel);
            console.log("poll owner:",pollData.owner);
            console.log("poll display:",pollData.display);
            console.log("poll EndsAt:",pollData.endsAt.seconds);
            console.log("poll Title:",pollData.title);
            $(".polltitle").text('Poll:' + pollData.title);
            // then looping through the options would be nice
            try{
                console.log("options:", pollData.options.length)
                // should do a element create and insert for the options
                $(".polloptions").empty();
                  
                var i = 0;
                // clear the option nodes
                while(i<pollData.options.length){
                    console.log(pollData.options[i].label,pollData.options[i].votes);
                    
                    const polltext = pollData.options[i].label;
                    const pollnum = i;
                    // should add these to our poll display area, should write the title and the options and be able to show the count info as well, with the timer (which would be nice or a progress bar)
                    var textnodePollOption = document.createElement("div");
                    textnodePollOption.innerHTML = pollData.options[i].label + " - " + pollData.options[i].votes; 
                    // add a on click handler for 
                    //const channel_action = 'changeChatChannel(\"' + el.channel + '\")'
                    textnodePollOption.addEventListener('click', function(e){
                        // do something
                        console.log('clikcked:', polltext);
                        console.log('clicked:', pollnum);
                        //changeChatChannel(el.channel);
                        console.log('we should have voted in the poll, and disabled voting anymore');
                        votePoll(pollnum); // should vote the index of the poll
                        }
                        
                        // might be nice to auto fill whispers here
                        // shitwave https://i.imgur.com/mEfgB8q.gif
                        // c band fun https://www.youtube.com/watch?v=eIKa0ytxBsg
                        // 2d tools for the shit box that is unity https://www.youtube.com/watch?v=2MImqNvgrNg&feature=youtu.be&list=PLUTYpMzyang7yEc48jcC7XW5_eS36A6Pf
                        // https://archive.org/details/TheOtherIsrael
                        // https://www.nlpu.com/Articles/eyemov1.gif
                        // https://snapcraft.io/makemkv
                        // will the beast run for 2020 https://www.predictit.org/markets/detail/4614/Will-Hillary-Clinton-run-for-president-in-2020
                        
                        // sassy feet https://ibb.co/5FpWwCv
                    );
                    
                    //const linkurl = baseurl + el.channel;
                    
                    
                    //$("polloptions").appendChild(textnodePollOption);
                    document.getElementById("pollingid").appendChild(textnodePollOption);
                    //$(".polloptions"); // should add a new node for each one
                    i++;
                }
                
            }catch(ex){
                console.log(ex);
            }
          //showPollClient = pollData.display;
        });
      }


function wc(data){
    // used to get the info from the server and set that we are officially connected to the whisper net 
    console.log('connected to the whisper net');
}

function handleNewViewerInfo(){
    $.get('https://chat.bitwave.tv/v1/channels', function(data, status){
        //console.log('Getting viewer info for channel...')
        //hydrate(data.data);
        /*if viewlist['success'] == True:
            for channel in viewlist['data']:
                if chatname == channel['channel']:
                    for viewer in channel.viewers:
                        unique_users.add(viewer)
                    viewer_count_for_channel = channel['viewCount']
        */
        
        var channel_selected = $( "#channelselect option:selected" ).text();
    var watchers = 0;
    var watchSetSize = new Set();
    var totalWatchersSetSize = new Set();
        //console.log(data);
        for( var user in data){
            var watcher = 'none';
            //console.log(user);
            //watchSetSize.add(watcher);
            try{
                watcher =  data[user].username.toLowerCase() //user.username
                //console.log('username:' + watcher);
                totalWatchersSetSize.add(watcher);
            }catch(err){
                //console.log('failed to get username...');
            }
            var cname = 'none';
            // try and get the user's channel name
            try{
                cname = data[user].page;
                //console.log('page name:'+cname);
                if( channel_selected.toLowerCase() == cname.toLowerCase()){
                    // try to add it
                    //console.log('watching: '+cname);
                    watchSetSize.add(watcher);
                }
            }catch(err){
            //console.log(err);
            }
            // check if it matches and try to add it to the set 
            
            try{
                cname = data[user].page.watch;
                //console.log('page watch name:'+cname);
                // do the check again and try to add again if it matches 
                if( channel_selected.toLowerCase() == cname.toLowerCase()){
                    // try to add it
                    //console.log('watching: '+cname);
                    watchSetSize.add(watcher);
                    //console.log('page watch name:'+cname);
                }
            }catch(err){
                //console.log(err);
            }
            
        }
        
        
        channel_watchers = watchSetSize;
        var total_watchers = 0;
    //watchers = watchSetSize.size;
    for( var ch in data.data){
        if(channel_selected.toLowerCase() == data.data[ch].channel){
            watchers = data.data[ch].viewCount
            // add the viewers 
            for(var viewer in data.data[ch].viewers){
                channel_watchers.add(data.data[ch].viewers[viewer]) 
            }
        }
        total_watchers += data.data[ch].viewCount
    }
    //console.log('set size for watch:' + watchers)
    //const total_watchers = totalWatchersSetSize.size;
    // update the displayed watch counter
    if(watchers >= 0){
        $("#watchcount").text("On Channel: " + watchers + " total: " + total_watchers);
    }else{
        $("#watchcount").text("On Channel: 0");
    }
    
    // update the list of displayed watchers
    // empty the list of users
    // document.getElementById("messageListContainer").appendChild(node);
    //var node = document.createElement("div"); 
    //textnodeUserName.innerHTML = el.username; 
    
    // need to clear the list of users
    //var watchers = document.getElementById("thewatchers");
    $("#thewatchers").empty();
    
    // var ignore_list = Array.from(ignore_set);
    var sorted_jerks = Array.from(channel_watchers);
    sorted_jerks.sort();
    for (var it = sorted_jerks.values(), val= null; val=it.next().value; ) {
            //console.log(val);
            var node = document.createElement("div"); 
            
            // create the avatar node
            const usernamet = val;
            
            const avatarlink = null;
            
            if(avatarlink){
        
                var textnodeAvatar = document.createElement("avatar");
                textnodeAvatar.innerHTML = "<img class=\"userav\" src=\"" + avatarlink + "\" >";
                textnodeAvatar.addEventListener('click', function(e){
                    // do something
                    var atmessage = $("textarea#message").val()
                        atmessage += "@" + usernamet + " ";
                        $("textarea#message").val(atmessage)
                        $("textarea#message").focus(); // send focus back to chat
                    }
                );
                node.appendChild(textnodeAvatar); 
            }else{
                var textnodeAvatar = document.createElement("avatar");
                
                
                textnodeAvatar.classList.add("avatar");
                //<i aria-hidden="true" class="v-icon material-icons theme--dark" style="background: rgb(32, 99, 223);">person</i>
                //textnodeAvatar.innerHTML = '<i aria-hidden="true" class="v-icon material-icons theme--dark userav" style="background: rgb(32, 99, 223);">person</i>';
                //textnodeAvatar.innerHTML = "<img class=\"userav\" src=\"https://i.imgur.com/kdxSQI9.png\" style=\"background: " + ucolor+";\">";
                textnodeAvatar.innerHTML = "<img class=\"userav\" src=\"https://bw.rnih.org/emotes/dead_sus_troll_standing.png\" style=\"background: rgb(32, 99, 223);\">";
                
                /*if(el.color){
                    const ucolor = el.color;
                    textnodeAvatar.innerHTML = '<i aria-hidden="true" class="v-icon material-icons theme--dark userav" style="background: '+ ucolor+';">person</i>';
                }*/
                textnodeAvatar.addEventListener('click', function(e){
                    // do something
                    var atmessage = $("textarea#message").val()
                        atmessage += "@" + usernamet + " ";
                        $("textarea#message").val(atmessage)
                        $("textarea#message").focus();// send focus back to chat
                    }
                );
                node.appendChild(textnodeAvatar); 
            
            }
            
            
            
            // create the name node
            
            var textnodeUserName = document.createElement("username"); // need to add a on click event for the attribute
            // need to add a onclick for username_click(el.username)
            textnodeUserName.addEventListener('click', function(e){
                // do something
                var atmessage = $("textarea#message").val()
                    atmessage = "!w " + usernamet + " " + atmessage;
                    $("textarea#message").val(atmessage)
                    $("textarea#message").focus();// send focus back to chat
                }
            );
            
            textnodeUserName.innerHTML = '<span style=" color: white;">' + usernamet + '</span>'; 
            
            
            
            node.appendChild(textnodeUserName);  
            
            var textnode = document.createElement("message");
            textnode.innerHTML = "<p>Ignore Toggle</p>"; 
            
            node.appendChild(textnode);  
            // add them to the new node
            
//        for( channel in ignore_set){
            //console.log(channel[channel].name);
            //console.log(channel[channel].title);
            //console.log(channel[channel].url);
            //const chname = ignore_set[channel];
            //const churl = channel_info_obj.users[channel].url;
            //const chlive = channel_info_obj.users[channel].live;
            //console.log(chname);
            //console.log(churl);
            
            //if(chlive ){
                //$('#fallenselect').append('<option value="' + val + '">' + val + '</option>');
            document.getElementById("thewatchers").appendChild(node);
            
            // shove in a br 
            var nodebr = document.createElement("br"); 
            //document.getElementById("thewatchers").appendChild(nodebr);
            //document.getElementById("thewatchers").appendChild(nodebr);
            document.getElementById("thewatchers").appendChild(nodebr);
    }
        
        
        
        
    });
}

handleNewViewerInfo();


function updateUserWatchInfo(data){
    // do a for loop
    //console.log('userlist item count:' + data.length);
    
    
    handleNewViewerInfo();
    
    /*try{
        var usrers_l = data;
    }catch(ex){
        console.log(ex);
    }
    //console.log(usrers_l);
    for( const user in data){
        //console.log('user:' + data[user].username);
    }*/
    
    
    
}

function messagein(data){
    
    if(data.to.toLowerCase() == username.toLowerCase()){
        //console.log('whisper came in from someone', data);
        console.log('from user:',data.from);
        console.log('to user:',data.to);
        //console.log('message:',data.message);
        console.log("can you keep a secret?")
        
        const msg_id = data.msg_id;
        const msg_to = data.from;
        const msg_from = data.to;
        
        const msg_to_add_locally = {
            message: "<p>" + data.message + "</p>",
            username: msg_to,
            channel: 'Whisper'
        
        }
        //ats
        dms.push(msg_to_add_locally);
        updateWhisperCount();
        //featureBingBingWahoo(data);
        bindSounds();
        playSound();
        addMessage(msg_to_add_locally);
        
        // send a receipt back to the server to be sent back to the sender
        const message_rct = {
            to: msg_to,
            from: msg_from,
            msg_id: msg_id
        
        }
        
        // add the message to the messages as a whisper
        whisperSocketServer.emit('receipt', message_rct) ;
    }
    
    
}

function said(data){
    // ZPE6F-KFWQ6-8WYT2


    //if(data.to.toLowerCase() == username.toLowerCase()){
        console.log('someone said something in litechat:', data);
        console.log('from user:',data.user);
        //console.log('to user:',data.to);
        console.log('message:',data.message);
        console.log('Users:', data.user_count);
        
        $('#lc_count').text("LC:" + data.user_count);
        
        const msg_id = data.msg_id;
        const msg_to = data.user;
        const msg_from = data.to;
        
        featureBingBingWahoo(data);
        
        
        const msg_to_add_locally = {
            message: "<p>" + data.message + "</p>",
            username: msg_to,
            channel: data.channel,
            avatar: 'https://bw.rnih.org/litechat/shh_litechat.jpg'
        
        }
        //ats
        dms.push(msg_to_add_locally);
        updateWhisperCount();
        addMessage(msg_to_add_locally);
        
        
    //}
    
    
}

function search(nameKey, myArray){
    for (var i=0; i < myArray.length; i++) {
        if (myArray[i].msg_id === nameKey) {
            return myArray[i];
        }
    }
}

function rr(data){
    if(data.to.toLowerCase() == username.toLowerCase()){
        //console.log('whisper receipt', data);
        // unpack the receipt and mark the message based on the random id that we orginally sent
        const msg_id = data.msg_id;
        
        // search theses
        var position = -1;
        if(sent_whispers){
            if(sent_whispers.length > 0){
                const tmesg = search(msg_id,sent_whispers);
                // and then remove it from the sent list and add it to the message window
                //console.log('message id found:',tmesg.msg_id);
                position = sent_whispers.indexOf(tmesg);
                //console.log('index in list:', position);
                var msg_to_add_locally = sent_whispers.pop(position);
                //console.log('we found and removed:',msg_to_add_locally);
                msg_to_add_locally.channel = "Whisper";
                msg_to_add_locally.username = msg_to_add_locally.from;
                msg_to_add_locally.message = '<p>Whisper sent to: ' + msg_to_add_locally.to + "</p>";
                addMessage(msg_to_add_locally);
            }
        }
        //console.log("we need to mark this message as recieved by the user");
        // the idea being that we will keep our outbound messages and then mark them as recv by adding them locally aka delivered
    }

}


console.log("after binding of the clients");

function featureAFK(message){
    if(chatFeatureAFK){
        if(message.message.toLowerCase().includes(username.toLowerCase())){
            var messagerollhelp = '@' + message.username + ' I am currently away';
            const msgHelp = {
                  message: messagerollhelp ,
                  channel: message.channel,
                };
                socket.emit('message', msgHelp);
        }
    }

}

function featureBingBingWahoo(message){
    if(chatFeatureNotify){
        if(message.message.toLowerCase().includes(username.toLowerCase())){
            bindSounds();
            playSound();
            //updateWhisperCount();
            const msg_to_add_locally = {
                message: message.message,
                username: message.username,
                channel: 'At'
            
            }
            //ats
            ats.push(msg_to_add_locally);
            updateAtCount();
        }
    }

}

function playSound() {
          var sound = document.getElementById("audio2");
          sound.muted = false;
          var promise = sound.play();

          if (promise !== undefined) {
              promise.then(_ => {
                  // Autoplay started!

              }).catch(error => {
                  // DO NOTHING BECAUSE THE USER CANT SEE THIS ELEMENT ON THE PAGE
              });
          }
      }

      function bindSounds(){
        // used to bind the sound sources to prevent them from playing intially
        // should look for a setting in storage to enable quad via /quad
        document.getElementById("audio2").src="https://www.myinstants.com/media/sounds/kitty-blabla.mp3";
        try{
            var quad_string =  window.localStorage.getItem('useQuad');
                if (quad_string === '1'){
                document.getElementById("audio2").src="https://bw.rnih.org/litechat/quad.mp3";
                }
            }catch(err){
            
        }
        
        try{
            var quad_string =  window.localStorage.getItem('useBones');
                if (quad_string === '1'){
                document.getElementById("audio2").src="https://bw.rnih.org/litechat/taunt.wav";
                }
            }catch(err){
            
        }
        
        try{
            var quad_string =  window.localStorage.getItem('useRail');
                if (quad_string === '1'){
                document.getElementById("audio2").src="https://bw.rnih.org/litechat/railgf1a.wav";
                }
            }catch(err){
            
        }
        
        // hit support useHit
        try{
            var quad_string =  window.localStorage.getItem('useHit');
                if (quad_string === '1'){
                document.getElementById("audio2").src="https://bw.rnih.org/litechat/hit.wav";
                }
            }catch(err){
            
        }
        
        try{
            var quad_string =  window.localStorage.getItem('useProtect');
                if (quad_string === '1'){
                document.getElementById("audio2").src="https://bw.rnih.org/litechat/protect.wav";
                }
            }catch(err){
            
        }
        
        try{
            var quad_string =  window.localStorage.getItem('useRunty');
                if (quad_string === '1'){
                document.getElementById("audio2").src="https://bw.rnih.org/litechat/runty.mp3";
                }
            }catch(err){
            
        }
        
        // adds support for menu sounds useMenu
        try{
            var quad_string =  window.localStorage.getItem('useMenu');
                if (quad_string === '1'){
                document.getElementById("audio2").src="https://bw.rnih.org/litechat/menu1.wav";
                }
                if (quad_string === '2'){
                document.getElementById("audio2").src="https://bw.rnih.org/litechat/menu2.wav";
                }
                if (quad_string === '3'){
                document.getElementById("audio2").src="https://bw.rnih.org/litechat/menu3.wav";
                }
                if (quad_string === '4'){
                document.getElementById("audio2").src="https://bw.rnih.org/litechat/menu4.wav";
                }
            }catch(err){
            
        }
        
      }
      
      function username_click(usernameat){
        // adds the @username to the message text
        
      }
      
function scrollToBottom(){
    if(forceScrollToBottom){
        scrollChat = true;
    }


    if(scrollChat){
        //textarea.scrollTop = textarea.scrollHeight;
        var messagecontainerlocal = document.getElementById('messageListContainer');
        // do the measurement and see if we are currently off of the bottom of chat
        if(do_scroll_based_on_height){
        
            messagecontainerlocal.scrollTop = messagecontainerlocal.scrollHeight;
            //document.querySelector("#messageListContainer > div:last-child").scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
        }
        
    }

}


// set a scroll to bottom timeout... that can run every 2 seconds
setInterval(function(){ scrollToBottom();},1000);

function clean_old_messages(){

    // get count of children and remove count > 100
    
    const counted = $("#messageListContainer div").length;
    //console.log("Counted:", counted);
    //console.log("");
    if(counted > qty_target_msgs){
        const amount_to_remove = counted - qty_target_msgs;
        $('#messageListContainer').find("div").slice(0, amount_to_remove).remove();
        console.log("removed:", amount_to_remove)
    }

}

function hexToRgb(hex) {
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

function removeDups(names) {
  let unique = {};
  try{
    names.forEach(function(i) {
        if(!unique[i]) {
        unique[i] = true;
        }
    });
  }catch(err){
  
  }
  return Object.keys(unique);
}

function checkForNewPremiumEmotes(){
    // does a call to the server to check the json data structure
    console.log('getting emotes');
    var temp_obj = null;
    const emotesurl="https://senatorhitlaisapedophile.com/emote/emotes.json";
    try{
    $.get(emotesurl, function(data, status){
        //alert("Data: " + data + "\nStatus: " + status);
        //console.log(data);
        //console.log(JSON.stringify(data, null, 4))
        const emoteinfo_str = JSON.stringify(data, null, 4);
        //console.log(emoteinfo_str);
        const emotes_info_obj =  JSON.parse(emoteinfo_str);
        console.log('after the parser runs');
        emotes_obj = emotes_info_obj;
        /*for( const emote in emotes_info_obj.emotes){
            const ename = emotes_info_obj.emotes[emote].name;
            const eurl = emotes_info_obj.emotes[emote].url;
            
            console.log('name:' + ename);
            console.log('url:' + eurl);
        }*/
        //temp_obj = emotes_info_obj;
        
    });
    }catch(err){
    
    }
    checkChatConnections();
    
}

checkForNewPremiumEmotes();

function processPremiumEmotes(messageText){
    var premiumEmotes = messageText;
    
    // do a loop over the emotes and do a search for all of the subs
    const use_server_side = true;
    if(use_server_side){
        /*var emotes_obj = { "emotes":
            [
                {
                    "name":"test2",
                    "url":"https://i.imgur.com/iBbkknJ.png"
                },
                {
                    "name":"cleo2",
                    "url":"https://media.discordapp.net/attachments/591084862283186197/594378480972464138/D-M1vhYXkAA3A-M.png?width=234&height=432"
                },
                
                {
                    "name":"test",
                    "url":"https://i.imgur.com/iBbkknJ.png"
                }
                
            ]
            };*/
        const emo_count = 0;
        //const emo_max = 0;
        try{
        if(!no_emotes){
            for( const emote in emotes_obj.emotes){
                const alt = emotes_obj.emotes[emote].name;
                const eurl = emotes_obj.emotes[emote].url;
                //console.log(alt,eurl);
                const matcher = ":"+ alt + ":/gi";
                const replacer = "<img src=\"" + eurl + "\" alt=\"" + alt + "\">";
                //premiumEmotes = premiumEmotes.replace('/:'+ alt +':/gi','<img src="' + eurl + '" alt="'+alt+'">');
                //const pattern = new RegExp(`[^\"]:${alt}:[^\"]`, 'gi' );
                const pattern = new RegExp(`:${alt}:`, 'gi' );
                //console.log(pattern);
                //console.log(replacer);
                //el.message = el.message.replace(pattern, `<span class="highlight">$&</span>`);
                premiumEmotes = premiumEmotes.replace(pattern,replacer);
                //console.log(premiumEmotes);
            }
        }
        }catch(ex){
        
        }
    }else{
        // riker https://imgur.com/a/dLKCYgL
        
        
    }
    // do global replace for :rngriker:
    return premiumEmotes;
}
      
var sanitizeHTML = function (str) {
	var temp = document.createElement('div');
	temp.textContent = str;
	return temp.innerHTML;
};
    
function addMessage(el){
    //console.log(el.username + ':',el.message);
    //gmessages += '[' + Date.now() + '] ' + el.username + ':\n' + el.message + "\n";
    
    
    if(do_ignore){
        if(is_user_ignored(el.username)){
            return;
        }
    
        if(is_ch_ignored(el.channel)){
            return;
        }
    }
    
    // would be nice to add date click to mute or click message to mute, or quote chat text, could add a mute button or M
    
    // need to build out the user ignore list/set
    
    // add a message to the ol
    var node = document.createElement("div");                 // Create a <li> node
    var textnode = document.createElement("message");         // Create a text node
    
    const pattern = new RegExp(`@${username}\\b`, 'gi' );
    el.message = el.message.replace(pattern, `<span class="highlight">$&</span>`);
    
    el.message = rainbowText(el.message);
    el.message = glowText(el.message);
    el.message = glowGreenText(el.message);
    
    // need to fix the less than to preven element creation
    // need to find and fix the ones that are not part of span or p
    // ((<|>)\w?).*
    // ((<>)\w?).*
    // ((?:\<\>)\w?).*
    // /((^<|^>)\w?).*/
    //el.message = el.message.replace(/\</g,"&lt;");
    el.message = el.message.replace(/<(?=[^>]*<)/g,"&lt;");
    el.message = el.message.replace(/<li>/g,"");
    el.message = el.message.replace(/<\/li>/g,"");
    el.message = el.message.replace(/<ul>/g,"<p>");
    el.message = el.message.replace(/<\/ul>/g,"</p>");
    
    
    // clean up script
    el.message = el.message.replace(/<script>/g,"");
    el.message = el.message.replace(/<\/script>/g,"");
    // clean up buttons 
    el.message = el.message.replace(/<button>/g,"");
    el.message = el.message.replace(/<\/button>/g,"");
    
    el.message = el.message.replace(/<input>/g,"");
    el.message = el.message.replace(/<\/input>/g,"");
    
    el.message = el.message.replace(/<title>/g,"");
    el.message = el.message.replace(/<\/title>/g,"");
    
    //el.message = el.message.replace(/((?:\<\>)\w?).*/g,"&lt;");
    el.message = processPremiumEmotes(el.message);
    textnode.innerHTML = el.message; // might need to be text
    // <div style="transform: rotate(-60deg); background: linear-gradient(#685300, #E6B800)">Hello litechat :smug: <div>
    //textnode.innerHTML = sanitizeHTML(el.message); // might need to be text
    bindToNewProfileName(el);
    
    var previewnode = document.createElement("previewer");
    
    /*$('message').linkpreview({
        previewContainer: "previewer",
        refreshButton: "#refresh-button",
        onSuccess: function(data) {
            console.log("Winner!");
        }
    })*/
    
    if(el.avatar){
        
        var textnodeAvatar = document.createElement("div");
        textnodeAvatar.classList.add("avatar");
        textnodeAvatar.innerHTML = "<img class=\"userav\" src=\"" + el.avatar + "\" >";
        textnodeAvatar.addEventListener('click', function(e){
            // do something
            var atmessage = $("textarea#message").val()
                atmessage += "@" + el.username + " ";
                $("textarea#message").val(atmessage)
                $("textarea#message").focus(); // send focus back to chat
            }
        );
        node.appendChild(textnodeAvatar); 
    }else{
        var textnodeAvatar = document.createElement("div");
        textnodeAvatar.classList.add("avatar");
        
        
        //<i aria-hidden="true" class="v-icon material-icons theme--dark" style="background: rgb(32, 99, 223);">person</i>
        //textnodeAvatar.innerHTML = '<i aria-hidden="true" class="v-icon material-icons theme--dark userav" style="background: rgb(32, 99, 223);">person</i>';
        textnodeAvatar.innerHTML = "<img class=\"userav\" src=\"https://bw.rnih.org/emotes/dead_sus_troll_standing.png\" style=\"background: rgb(32, 99, 223);\">";
        if(el.color){
            const ucolor = el.color;
            //textnodeAvatar.innerHTML = '<i aria-hidden="true" class="v-icon material-icons theme--dark userav" style="background: '+ ucolor+';">person</i>';
            textnodeAvatar.innerHTML = "<img class=\"userav\" src=\"https://bw.rnih.org/emotes/dead_sus_troll_standing.png\" style=\"background: " + ucolor + ";\">";
        }
        textnodeAvatar.addEventListener('click', function(e){
            // do something
            var atmessage = $("textarea#message").val()
                atmessage += "@" + el.username + " ";
                $("textarea#message").val(atmessage)
                $("textarea#message").focus();// send focus back to chat
            }
        );
        node.appendChild(textnodeAvatar); 
    
    }
    
    var textnodeDate = document.createElement("div");
    textnodeDate.classList.add("date");
    var theDate = new Date()
    if(el.timestamp){
        theDate = new Date(el.timestamp)
    }
    const dateString = theDate.toLocaleTimeString();
    textnodeDate.innerHTML = '[' + dateString + ']'; 
    // add a click event to ignore toggle the user
    
    textnodeDate.addEventListener('click', function(e){
            // do something
            console.log('toggle ignore for: ' + el.username);
            add_remove_to_ignore(el.username);
            }
        );
    
    // could just have hit do it on a second click if it already has the whisper command in the window...
    
    var textnodeUserName = document.createElement("div"); // need to add a on click event for the attribute
    textnodeUserName.classList.add("username");
    // need to add a onclick for username_click(el.username)
    textnodeUserName.addEventListener('click', function(e){
        // do something
        var atmessage = $("textarea#message").val()
            //if (atmessage.length > ("!w " + el.username).length){
                
                if(atmessage.includes("!w " + el.username)){
                    // do nothing.... it's already in the message
                    atmessage = atmessage.replace('!w ', '!ww ')
                }else{
                    
                    if(atmessage.includes("!ww " + el.username)){
                        //atmessage = "!w " + el.username + " " + atmessage;
                        atmessage = atmessage.replace('!ww ', '!w ')
                    }else{
                        atmessage = "!w " + el.username + " " + atmessage;
                    }
                    
                }
                
            //}
            $("textarea#message").val(atmessage)
            $("textarea#message").focus();// send focus back to chat
        }
    );
    
    /*textnodeUserName.addEventListener('dblclick',function(e){
        // do something
        // maybe do a regex to sub "!w " to "!ww "
        var atmessage = $("textarea#message").val()
            //atmessage = "!ww " + el.username + " " + atmessage;
            atmessage = atmessage.replace('!w ', '!ww ')
            $("textarea#message").val(atmessage)
            $("textarea#message").focus();// send focus back to chat
        }
    );*/
    
    textnodeUserName.innerHTML = el.username; 
    if( el.color){
        const ucolor = el.color;
        // neeed to convert the color probably....
        //console.log("color found:", ucolor)
        textnodeUserName.innerHTML = '<span style=" color: '+ ucolor +';">'+el.username + '</span>'; 
    }
    
    if(el.userColor){
        const ucolor = el.userColor;
        // neeed to convert the color probably....
        //console.log("color found:", ucolor)
        textnodeUserName.innerHTML = '<span style=" color: '+ ucolor +';">'+el.username + '</span>'; 
    
    }
    
    // check if they have a local flag in the message or not
    if(el.global == false){
        console.log("found a global message");
    
        //textnodeDate.addClass("localfag");// add class for localfag
        textnodeDate.classList.add("localfag");
        //textnodeUserName.classList.add("localfag");
    }
    
    
    var textnodeChannelName = document.createElement("div");
    textnodeChannelName.classList.add("channel");
    textnodeChannelName.innerHTML = el.channel; 
    // add a on click handler for 
    //const channel_action = 'changeChatChannel(\"' + el.channel + '\")'
    textnodeChannelName.addEventListener('click', function(e){
        // do something
        //console.log('clikcked:', el.channel);
        changeChatChannel(el.channel);
        }
        
        // might be nice to auto fill whispers here
    );
    
    const linkurl = baseurl + el.channel;
    
      
    node.appendChild(textnodeDate);     
    node.appendChild(textnodeUserName);     
    node.appendChild(textnodeChannelName);     
    //node.appendChild(textnode);     
    
    node.appendChild(textnode);                              // Append the text to <li>
    //node.appendChild(el.message);
    document.getElementById("messageListContainer").appendChild(node);     // Append <li> to <ul> with id="myList"
    
    //$("textarea#messages").val(gmessages);
    var textarea = document.getElementById('messages');
    scrollToBottom();
    
    /*$('img').onImgLoad('img', function(){
        //$(this).fadeIn(700);
        scrollToBottom();
    });*/
    
}

function rainbowText(message){
    return message.replace(/\==(.*?)\==/g,`<p class="rainbow-text"> $& </p>`)
    .replace(/\==/g,'')
    // instead of returning we could get the match, then do a sub string replace in it to clean up the double =='s after the fact
}
                
function glowText(message){
    return message.replace(/\++(.*?)\++/g,`<p class="glow"> $& </p>`)
    .replace(/\+\+/g,'')
    // instead of returning we could get the match, then do a sub string replace in it to clean up the double =='s after the fact
}

function glowGreenText(message){
    return message.replace(/\+=(.*?)\=+/g,`<p class="glowgreen"> $& </p>`)
    .replace(/\+\=/g,'').replace(/\=\+/g,'')
    // instead of returning we could get the match, then do a sub string replace in it to clean up the double =='s after the fact
}

function addAlert(data){
    // nigger alerts are dumb, but they will probably be silent and hidden somewhere in chat or will be and pop up overlay box that will be abs and hidden
    // alerts Alerts:
    // data.message
    const m = {
          _id: data._id,
          type: 'alert',
          message: data.message,
          color: data.color,
          channel: data.channel
        };
        
        //data.message
    
    alerts.push(data);
    var dms_text = "";
    alerts.forEach( el => {
        
        function unescapeHtml(unsafe) {
                return unsafe
                    .replace(/&amp;/g,  `&`)
                    .replace(/&lt;/g,   `<`)
                    .replace(/&gt;/g,   `>`)
                    .replace(/&quot;/g, `"`)
                    .replace(/&#39;/g,  `'`)
                }

                el.message = unescapeHtml( el.message ); // Fixes escaped characters
                el.message = el.message.replace(/<(?=[^>]*<)/g,"&lt;");
    el.message = el.message.replace(/((?:\<\>)\w?).*/g,"&lt;");
    el.message = el.message.replace(/<\/?[^>]*>/g, '');
        
        // Remove Links
        //el.message = el.message.replace(/((https?:\/\/)|(www\.))[^\s]+/gi, '');
    //el.message = processPremiumEmotes(el.message);
    // red pink yellow
    // might turn this into a div to display and format the data better
        dms_text += el.channel + " " + el.color + ": " + el.message + "\n";
    });
    
    $("textarea#alerts").val(dms_text);
        
        
    
     $('#alerts_count').text("Alerts:" + alerts.length);
}

function addChannel(chname){
    // go through the list of channels and add this if it isn't in the set...
    //channels.add(chname);
    
    // build a list of channels in the select box and then use it to de dupe (or have it be a set)
    // probably needs escaped to be only . and alphanums and - _
    var cleaner = /[^a-zA-Z0-9\_\-\.]/g;
    var clean_channel = chname.replace(cleaner,"");
    channels.add(clean_channel);
    $('#channelselect').empty();
    for (var it = channels.values(), val= null; val=it.next().value; ) {
        $('#channelselect').append('<option value="' + val + '">' + val + '</option>');
    }

}

function rcvMessageBulk (messages) {
    //console.log("do something");
    

    
        const pattern = new RegExp(`@${this.username}\\b`, 'gi' );
        messages.forEach( el => {
        
                // log the message, user, time, channel
                
                
                
                function unescapeHtml(unsafe) {
                return unsafe
                    .replace(/&amp;/g,  `&`)
                    .replace(/&lt;/g,   `<`)
                    .replace(/&gt;/g,   `>`)
                    .replace(/&quot;/g, `"`)
                    .replace(/&#39;/g,  `'`)
                }

                //el.message = unescapeHtml( el.message ); // Fixes escaped characters
                
                // .rainbow-text for == ==
                // https://fam.tuwien.ac.at/~schamane/_/mycolorize
                // should find the locations for the == start and end == 
                // count == matches, group them, see if there is an even count, even put opens, odds put closing tags
                // /\==(.*?)\==/g
                
                addChannel(el.channel);
                //el.message = rainbowText(el.message);
                featureAFK(el);
                //featureToggleTtsViaChat(el);
                featureBingBingWahoo(el); // this is early enough that you know when someone that was ignored is trying to @you
                //featureRollAll(el);
                // need to strip out the html mark up and images
                // need to do a measure before we do an add and set our state of
                checkAutoScrollBasedOnHeight();
                var do_add_message = true; // the default method is to add messages to the ui, only if we have on advanced filtering do we look
                // for reasons to not add it to the message queue
                // so yeah adding via the no add pipe line design I think is the best, set based on reasons we want to to filter messages
                // is the easiest way to do it
                
                if($("#filterchattrolls").prop( "checked" )){
                    // determine if the message is from a troll or not
                    if(el.username.includes('troll:')){
                        do_add_message = false;
                    }
                }
                
                // then read the chat messages
                if($("#filterchatbychannel").prop( "checked" )){
                    // only add messages that are in the channel that we are in/selected
                    //console.log("We should only add messages that are in our channel that we have selected");
                    const tempchannel = $( "#channelselect option:selected" ).text();
                    const myChat      = el.channel.toLowerCase() === tempchannel.toLowerCase();
                    if(myChat || el.channel.toLowerCase() == "whisper"){
                         
                        
                    }else{
                        do_add_message = false;
                    
                    }
                }
                // check if the user is in the ignore list
                try{
                    if(is_user_ignored(el.username.toLowerCase())){
                        do_add_message = false;
                        //console.log('said that we should ignore the user...');
                    }
                }catch(err){
                
                }
                
                if(el.message.toLowerCase().includes(username.toLowerCase())){
                    do_add_message = true;
                }
                
                
                
                if(do_add_message){
                    if(useTTS){
                        if($("#filterchatbychannel").prop( "checked" )){
                            if(el.channel){
                            
                                //const myChat      = el.channel.toLowerCase() === channel.toLowerCase();
                                //if(myChat){
                                const tempchannel = $( "#channelselect option:selected" ).text();
                                const myChat      = el.channel.toLowerCase() === tempchannel.toLowerCase();
                                if(myChat){
                                    var message_to_read = el.message;
                                    if(read_names){
                                        message_to_read =  el.username.toLowerCase() + " says " + message_to_read;
                                    }
                                    readTTSmessage(message_to_read);
                                }
                            }
                        }else{
                            var message_to_read = el.message;
                            if(read_names){
                                message_to_read =  el.username.toLowerCase() + " says " + message_to_read;
                            }
                            readTTSmessage(message_to_read);
                        }
                    }
                    // should check if it contains [to: username] for the start of the message
                    const whisperPreamble = "[to: " + username + "] ";
                    if(el.message.includes(whisperPreamble)){
                        const msg_to_add_locally = {
                            message: el.message,
                            username: username,
                            channel: el.channel
                        
                        }
                        dms.push(msg_to_add_locally);
                        updateWhisperCount();
                    }
                    addMessage(el);
                }
                
                
          // Highlight username tags in new messages
          
        });

        //await this.$nextTick( async () => await this.scrollToBottom() );
        
        clean_old_messages();
      }
      
function featureToggleTtsViaChat(message){
    if(true){
        // need to check if we want to toggle tts via chat or via the owner
        const currentChat = message.channel.toLowerCase() === username.toLowerCase();
        const myChat      = message.channel.toLowerCase() === channel.toLowerCase();
        if(allowTrollsToToggleTTS){
        if(message.message.toLowerCase().includes("ttstoggleon")){
            // do tts change status
            useTTS = true;
            toggleTTS();
            console.log("test turn on tts");

        }
        if(message.message.toLowerCase().includes("ttstoggleoff")){
            // do tts change status
            useTTS = false;
            toggleTTS();
            console.log("test turn off tts");

        }
        }

        // have a flag allow chat to turn it on and off
        // have a switch for
        if(currentChat){
        if(message.message.toLowerCase().includes("ttstoggleon")){
            // do tts change status
            useTTS = true;
            toggleTTS();
            console.log("test turn on tts");

        }
        if(message.message.toLowerCase().includes("ttstoggleoff")){
            // do tts change status
            useTTS = false;
            toggleTTS();
            console.log("test turn off tts");

        }
        }
    }

}
    
function toggleTTS () {
        speechSynthesis.cancel();
        //localStorage.setItem( 'tts', useTTS );
}
      
      
$("textarea#message").keyup(function(e){
    if((e.keyCode || e.which) == 13) { //Enter keycode
        if (e.shiftKey) {
            sendPremium();
        }else{
            send();
        }
    }
    if((e.keyCode || e.which) == 38) { //UP keycode
        //send();
        if($("textarea#message").val().length == 0 || send_buffer_index > 0){
            const msg = sendbuffer[send_buffer_index];
            $("textarea#message").val(msg);
            send_buffer_index += 1;
            // scroll throw the command buffer
            if(send_buffer_index > sendbuffer.length){
                send_buffer_index = sendbuffer.length-1;
            }
        }
    }
    if((e.keyCode || e.which) == 40) { //UP keycode
        //send();
        // scroll throw the command buffer
        
        // should check the message length before we change the message to use the buffer
        if($("textarea#message").val().length == 0 || send_buffer_index > 0 ){
            const msg = sendbuffer[send_buffer_index];
            $("textarea#message").val(msg);
            send_buffer_index -= 1;
            //send_buffer_index = 0;
            if(send_buffer_index < 0){
                send_buffer_index = 0;
            }
        }
    }
    // left 37
    // right 39
});

function checkAutoScrollBasedOnHeight(){
    var messagecontainerlocal = document.getElementById('messageListContainer');
        if(messagecontainerlocal.scrollTop < messagecontainerlocal.scrollHeight - 100){
            do_scroll_based_on_height = true;
        }else{
            do_scroll_based_on_height = true;
        }
}

function getRngEmote(ename,start,end){
    const selectedid = Math.floor(Math.random() * end);
    var emotenamed = ename + selectedid;
    if( selectedid == 1 || selectedid ==  0){
        emotenamed = ename;
    }
    return emotenamed;
}


function getRandomRiker(){
    var rikerFact = 'https://i.imgur.com/iBbkknJ.png';
    var rikerChestBeard = 'https://i.imgur.com/R0R16jW.png';
    var rikerPimp = 'https://i.imgur.com/6Er0BrO.png';
    var rikerDootDoot = 'https://i.imgur.com/6Er0BrO.png';
    var rikers = [rikerFact,rikerChestBeard,rikerPimp,rikerDootDoot];
    const selectedid = Math.floor(Math.random() * rikers.length);
    const riker = rikers[selectedid];
    
    return riker;
}


function hydratev2 (data) {
    if ( !data ) {
            console.log('Failed to receive hydration data');
            return;
            }
            const size = data.size;
            if ( !size ) {
            console.log('Hydration data was empty');
            return;
            }
}

    function hydrate (data) {
        if(true){
            //await this.socket.emit('hydratepoll', this.pollData.id); // should request if this poll is still going on and send us back a poll
            if ( !data ) {
            console.log('Failed to receive hydration data');
            return;
            }
            const size = data.length;
            if ( !size ) {
            console.log('Hydration data was empty');
            return;
            }
            //this.messages = size > 100 ? data.splice(-this.chatLimit) : data;
            //await this.$nextTick( async () => await this.scrollToBottom(true) );
            // re-highlight username mentions on hydration
            const pattern = new RegExp( `@${this.username}\\b`, 'gi' );
            
            // need to do a measure before we do an add and set our state of
            checkAutoScrollBasedOnHeight();
            
            // should trim down the buffer size by getting rid of the everything but the most recent 10-20
            const qty_target = 10;
            const counted = data.length;
            console.log("Counted:", counted);
            console.log("");
            if(counted > qty_target){
                const amount_to_remove = counted - qty_target;
                data = data.slice(amount_to_remove, counted);
                console.log("removed:", amount_to_remove)
            }
            
            data.forEach( msg => {
            msg.message = msg.message.replace(pattern, `<span class="highlight">$&</span>`);
             var do_add_message = true; // the default method is to add messages to the ui, only if we have on advanced filtering do we look
                // for reasons to not add it to the message queue
                // so yeah adding via the no add pipe line design I think is the best, set based on reasons we want to to filter messages
                // is the easiest way to do it
                
                if($("#filterchattrolls").prop( "checked" )){
                    // determine if the message is from a troll or not
                    if(msg.username.includes('troll:')){
                        do_add_message = false;
                    }
                }
                
                // then read the chat messages
                if($("#filterchatbychannel").prop( "checked" )){
                    // only add messages that are in the channel that we are in/selected
                    //console.log("We should only add messages that are in our channel that we have selected");
                    const tempchannel = $( "#channelselect option:selected" ).text();
                    const myChat      = msg.channel.toLowerCase() === tempchannel.toLowerCase();
                    if(myChat){
                         
                        
                    }else{
                        do_add_message = false;
                    
                    }
                }
                // check if the user is in the ignore list
                try{
                    if(is_user_ignored(msg.username.toLowerCase())){
                        do_add_message = false;
                        //console.log('said that we should ignore the user...');
                    }
                }catch(err){
                
                }
                
                if(do_add_message){
                    addMessage(msg);
                }
            //addMessage(msg);
            });
            clean_old_messages();
        }
      }
      
      function featureRollAll(message){

        // spookys official list https://cdn.discordapp.com/attachments/582410542182826004/582417420078153729/unknown.png
        //this.featureRoll100(message);
        // do some checks on who can use the botroll features via my white list that will be in browser?
        if(username.toLowerCase() != "markpugner"){
            featureRoll20(message);
            featureRoll12(message);
            featureRoll10(message);
            featureRoll8(message);
            featureRoll6(message);
            featureRoll4(message);
            //.featureRoll3(message);
            //this.featureRoll2(message);
            featureRollHelp(message);
        }

      }
      
      function featureRollHelp(message){
        if(true){
          if(message.message.toLowerCase().includes("botrollon")){
           botrollEnabled = true;
          }

          if(message.message.toLowerCase().includes("botrolloff")){
            botrollEnabled = false;
          }

          if(message.message.toLowerCase().includes("botrollhelp")){


            var messagerollhelp = '@' + message.username + ' You can roll a 4,6,8,10,20 sided dice';
            const msgHelp = {
                  message: messagerollhelp ,
                  channel: channel,
                };
                socket.emit('message', msgHelp);
          }
        }

      }
      
      function featureRoll10(message){
        if(botrollEnabled){
          if(message.message.toLowerCase().includes("botroll10")){
          // spooky says  2, 3, 4, 6, 10, 20 and 100 i and 8
            const rng20 = Math.floor(Math.random() * 10) + 1;
            var messageroll = '@' + message.username + ' You rolled a ' + rng20 + ' on a 10';
            const msg20x = {
                  message: messageroll ,
                  channel: channel,
                };
                socket.emit('message', msg20x);
          }
        }

      }
      
      function featureRoll8(message){
        if(botrollEnabled){
          if(message.message.toLowerCase().includes("botroll8")){
          // spooky says  2, 3, 4, 6, 10, 20 and 100 i and 8
            const rng20 = Math.floor(Math.random() * 8) + 1;
            var messageroll = '@' + message.username + ' You rolled a ' + rng20 + ' on a 8';
            const msg20x = {
                  message: messageroll ,
                  channel: channel,
                };
                socket.emit('message', msg20x);
          }
        }

      }
      
      function featureRoll6(message){
        if(botrollEnabled){
          if(message.message.toLowerCase().includes("botroll6")){
          // spooky says  2, 3, 4, 6, 10, 20 and 100 i and 8
            const rng20 = Math.floor(Math.random() * 6) + 1;
            var messageroll = '@' + message.username + ' You rolled a ' + rng20 + ' on a 6';
            const msg20x = {
                  message: messageroll ,
                  channel: channel,
                };
                socket.emit('message', msg20x);
          }
        }

      }
      
      function featureRoll4(message){
        if(botrollEnabled){
          if(message.message.toLowerCase().includes("botroll4")){
          // spooky says  2, 3, 4, 6, 10, 20 and 100 i and 8
            const rng20 = Math.floor(Math.random() * 4) + 1;
            var messageroll = '@' + message.username + ' You rolled a ' + rng20 + ' on a 4';
            const msg20x = {
                  message: messageroll ,
                  channel: channel,
                };
                socket.emit('message', msg20x);
          }
        }

      }
      
      function featureRoll12(message){
        if(botrollEnabled){
          if(message.message.toLowerCase().includes("botroll12")){
          // spooky says  2, 3, 4, 6, 10, 20 and 100 i and 8
            const rng20 = Math.floor(Math.random() * 12) + 1;
            var messageroll = '@' + message.username + ' You rolled a ' + rng20 + ' on a 12';
            const msg20x = {
                  message: messageroll ,
                  channel: channel,
                };
                socket.emit('message', msg20x);
          }
        }

      }
      
      function featureRoll20(message){
        if(botrollEnabled){
          if(message.message.toLowerCase().includes("botroll20")){
          // spooky says  2, 3, 4, 6, 10, 20 and 100 i and 8
            const rng20 = Math.floor(Math.random() * 20) + 1;
            var messageroll = '@' + message.username + ' You rolled a ' + rng20 + ' on a 20';
            const msg20x = {
                  message: messageroll ,
                  channel: channel,
                };
                socket.emit('message', msg20x);
          }
        }

      }
      
      function roll(n){
         return Math.floor(Math.random() * n) + 1
      }
        //restartConnection();
      setInterval(function(){ getChannelInfo(); }, 15000);
      setInterval(function(){ checkForNewPremiumEmotes();},20000);
      setTimeout(function(){ restartConnection(); }, 3000);
      
      /*grecaptcha.ready(function() {
            grecaptcha.execute('6LcEX8QUAAAAADjiUPfbzkyn0KYAaEK263quzCGh', {action: 'litechat'}).then(function(token) {
            activeUserProfile.recaptcha = token; // set our recaptcha
            //activeUserProfile.recaptcha = rtoken;
            //console.log('Recaptoken:',token);
            console.log(token);
            
                //grecaptcha.execute('6LcEX8QUAAAAADjiUPfbzkyn0KYAaEK263quzCGh', {action: 'litechat'}).then( token => {console.log('should have done stuff...',token)} )
            //console.log("what the fuck good is recaptcha if it doesn't even work as expected....");
            //return recaptcha;
            })
        });*/
</script>

</body></html>
